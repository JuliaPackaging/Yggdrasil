# Trigger on pushes to `master`
trigger:
- master

# Trigger on PRs against `master`
pr:
- master

# By default, use the `Native` pool of agents
pool: Native

variables:
    JULIA: unbuffer julia --project=$(Build.SourcesDirectory)/.ci --color=yes

jobs:
- job: generator
  steps:
  - checkout: self
    fetchDepth: 99999
    clean: true
  - bash: |
      # Be fragile, like a beautiful porcelain doll
      set -e

      # Normally we look at the last pushed commit
      COMPARE_AGAINST="HEAD~1"

      # If we're on a PR though, we look at the entire branch at once
      if [[ $(Build.Reason) == "PullRequest" ]]; then
          COMPARE_AGAINST="remotes/origin/$(System.PullRequest.TargetBranch)"
      fi

      # Get the directories holding changed files
      # 1. All changed files
      # 2. Only files in directories
      # 3. dirname
      # 4. Unique the directories
      PROJECTS=$(git diff-tree --no-commit-id --name-only -r HEAD "${COMPARE_AGAINST}" | grep -E ".+/.+"| sed 's#/[^/]*$##' | sort -u)

      # If there are scary projects we need to exclude, we list them here. (Used to contain `LLVM`)
      EXCLUDED_NAMES=" "

      # This is the dynamic mapping we're going to build up, if it's empty we don't do anything
      PROJECTS_ACCEPTED=""
      for PROJECT in ${PROJECTS}; do
          NAME=$(basename "${PROJECT}")
          echo "Considering ${PROJECT}"
          # Only accept things that contain a `build_tarballs.jl`
          if [[ ! -f "${PROJECT}/build_tarballs.jl" ]]; then
              echo " --> Skipping as it does not have a build_tarballs.jl"
              continue
          fi

          # Ignore RootFS stuff, we'll do that manually
          if [[ "${PROJECT}" == "0_RootFS/"* ]]; then
              echo " --> Skipping as it's within 0_RootFS/"
              continue
          fi

          # Ignore stuff in our excluded projects
          if [[ "${EXCLUDED_NAMES}" == *" ${NAME} "* ]]; then
              echo " --> Skipping as it's excluded"
              continue
          fi

          # Otherwise, emit a build with `PROJECT` set to `${PROJECT}`
          echo " --> Accepted!"
          PROJECTS_ACCEPTED="${PROJECTS_ACCEPTED} ${PROJECT}"
      done
      if [[ -n "${PROJECTS_ACCEPTED}" ]]; then
          if [[ $(echo "${PROJECTS_ACCEPTED}" | awk '{print NF}') -gt 5 ]]; then
              echo "Too many projects requested"
              exit 1
          fi

          # Next, we're going to ensure that our BB is up to date and precompiled
          $(JULIA) -e "import Pkg; Pkg.instantiate(); using BinaryBuilder"

          # We're going to snarf out the BB tree hash, to be used later in our build cache
          BB_HASH=$($(JULIA) -e "using Pkg; print(Pkg.Types.Context().env.manifest[Pkg.Types.UUID(\"12aac903-9f7c-5d81-afc2-d9565ea332ae\")].tree_hash)")

          # Next, for each project, download its sources. We do this by generating meta.json
          # files, then parsing them with `download_sources.jl`
          for PROJECT in ${PROJECTS_ACCEPTED}; do
              NAME=$(basename ${PROJECT})

              # We always invoke a `build_tarballs.jl` file from its own directory
              pushd ${PROJECT} >/dev/null
              echo "Generating meta.json..."
              JSON_PATH="$(Agent.TempDirectory)/${NAME}.meta.json"
              $(JULIA) ./build_tarballs.jl --meta-json="${JSON_PATH}"
              echo "Downloading sources..."
              $(JULIA) $(Build.SourcesDirectory)/.ci/download_sources.jl "${JSON_PATH}" $(Agent.TempDirectory)/${NAME}.platforms.list

              # Pop back up to the overworld
              popd >/dev/null
          done

          # Emit project variable declarations
          echo -n "##vso[task.setVariable variable=projects;isOutput=true]{"
          for PROJECT in ${PROJECTS_ACCEPTED}; do
              NAME=$(basename ${PROJECT})
              PLATFORMS=$(cat $(Agent.TempDirectory)/${NAME}.platforms.list)
              echo -n "'${NAME}':{'NAME': '${NAME}', 'PROJECT':'${PROJECT}', 'PLATFORMS':'${PLATFORMS}'}, "
          done
          echo "}"

          # Emit project/platform joint variable declarations
          echo -n "##vso[task.setVariable variable=projplatforms;isOutput=true]{"
          for PROJECT in ${PROJECTS_ACCEPTED}; do
              NAME=$(basename ${PROJECT})

              # "project source hash" is a combination of meta.json (to absorb
              # changes from include()'ing a `common.jl`) as well as the entire
              # tree the project lives in (to absorb changes from patches)
              TREE_HASH=$($(JULIA) -e "using Pkg; print(bytes2hex(Pkg.GitTools.tree_hash(\"${PROJECT}\")))")
              META_HASH=$(shasum -a 256 "$(Agent.TempDirectory)/${NAME}.meta.json" | cut -d' ' -f1)
              PROJ_HASH=$(echo -n ${TREE_HASH}${META_HASH} | shasum -a 256 | cut -d' ' -f1)

              # Load in the platforms
              PLATFORMS=$(cat $(Agent.TempDirectory)/${NAME}.platforms.list)
              if [[ -z "${PLATFORMS}" ]]; then
                  echo "Unable to determine the proper platforms for ${NAME}" >&2
                  continue
              fi
              for PLATFORM in ${PLATFORMS}; do
                  # Here, we hit the build cache to see if we can skip this particular combo
                  CACHE_URL="https://julia-bb-buildcache.s3.amazonaws.com/${BB_HASH}/${PROJ_HASH}/${PLATFORM}.tar.gz"
                  if curl --output /dev/null --silent --fail --HEAD "${CACHE_URL}"; then
                      continue;
                  fi

                  # Otherwise, emit the build
                  echo -n "'${NAME}-${PLATFORM}':{ \
                      'NAME': '${NAME}', \
                      'PROJECT':'${PROJECT}', \
                      'PLATFORM':'${PLATFORM}', \
                      'PROJ_HASH':'${PROJ_HASH}', \
                      'BB_HASH':'${BB_HASH}' \
                  }, "
              done
          done
          echo "}"
      fi
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    name: mtrx

- job: jll_init
  dependsOn: generator
  timeoutInMinutes: 10
  cancelTimeoutInMinutes: 2
  strategy:
    matrix: $[ dependencies.generator.outputs['mtrx.projects'] ]
  variables:
    projects: $[ dependencies.generator.outputs['mtrx.projects'] ]
  steps:
  - script: |
      cd $(PROJECT)
      echo "Generating meta.json..."
      $(JULIA) ./build_tarballs.jl --meta-json=$(Agent.TempDirectory)/$(NAME).meta.json
      echo "Initializing JLL package..."
      $(JULIA) $(Build.SourcesDirectory)/.ci/jll_init.jl "$(Agent.TempDirectory)/${NAME}.meta.json"
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    displayName: "initialize JLL package"
    condition: and(and(ne(variables['Build.Reason'], 'PullRequest'), eq(variables['Build.SourceBranch'], 'refs/heads/master')), ne(variables['projects'], ''))

- job: build
  dependsOn:
   - generator
   - jll_init
  timeoutInMinutes: 240
  cancelTimeoutInMinutes: 2
  strategy:
    matrix: $[ dependencies.generator.outputs['mtrx.projplatforms'] ]
  variables:
    projplatforms: $[ dependencies.generator.outputs['mtrx.projplatforms'] ]
  steps:
  - script: |
      # Cleanup temporary things that might have been left-over
      ./clean_builds.sh
      ./clean_products.sh

      cd $(PROJECT)
      $(JULIA) ./build_tarballs.jl --verbose $(PLATFORM)

      # After building, we take the single tarball produced with the proper NAME, and upload it:
      TARBALLS=( ./products/${NAME}*${PLATFORM}*.tar.gz )
      if [[ "${#TARBALLS[@]}" != 1 ]]; then
          echo "Multiple tarballs?  This isn't right!" >&2
          exit 1
      fi

      # Upload with curl
      ACL="x-amz-acl:public-read"
      CONTENT_TYPE="application/x-gtar"
      BUCKET="julia-bb-buildcache"
      BUCKET_PATH="${BB_HASH}/${PROJ_HASH}/${PLATFORM}.tar.gz"
      S3SIGNATURE=$(echo -en "PUT\n\n${CONTENT_TYPE}\n$(date -R)\n${ACL}\n/${BUCKET}/${BUCKET_PATH}" | openssl sha1 -hmac "${S3SECRET}" -binary | base64)
      HOST="${BUCKET}.s3.amazonaws.com"
      echo "Uploading artifact to https://${HOST}/${BUCKET_PATH}"
      curl -X PUT -T "${TARBALLS[0]}" \
          -H "Host: ${HOST}" \
          -H "Date: $(date -R)" \
          -H "Content-Type: ${CONTENT_TYPE}" \
          -H "${ACL}" \
          -H "Authorization: AWS ${S3KEY}:${S3SIGNATURE}" \
          "https://${HOST}/${BUCKET_PATH}"

    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
      S3KEY: $(S3KEY)
      S3SECRET: $(S3SECRET)
    displayName: "run build_tarballs.jl"
    condition: and(ne(variables['projplatforms'], ''), ne(variables['projplatforms'], '{}'))

- job: register
  dependsOn:
  - generator
  - build
  strategy:
    matrix: $[ dependencies.generator.outputs['mtrx.projects'] ]
    maxParallel: 1
  variables:
    projects: $[ dependencies.generator.outputs['mtrx.projects'] ]
  steps:
  - script: |
      cd $(PROJECT)
      echo "Generating meta.json..."
      $(JULIA) ./build_tarballs.jl --meta-json=$(Agent.TempDirectory)/$(NAME).meta.json
      echo "Registering $(NAME)..."
      export BB_HASH PROJ_HASH
      $(JULIA) $(Build.SourcesDirectory)/.ci/register_package.jl $(Agent.TempDirectory)/$(NAME).meta.json --verbose
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    displayName: "register JLL package"
    # We only register if this is on `master`; same as setting `${DEPLOY}` above.
    condition: and(and(ne(variables['Build.Reason'], 'PullRequest'), eq(variables['Build.SourceBranch'], 'refs/heads/master')), ne(variables['projects'], ''))

