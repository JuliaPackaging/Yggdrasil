diff --git a/src/util.h b/src/util.h
index ce26160bd..1f1c3b820 100644
--- a/src/util.h
+++ b/src/util.h
@@ -331,14 +331,14 @@ void libxc_free(void *ptr);
 #else
 
 template <class int_type>
-auto libxc_malloc(const int_type size){
+void* libxc_malloc(const int_type size){
   void * mem;
   cudaMallocManaged(&mem, size);
   return mem;
 }
 
 template <class int_type1, class int_type2>
-auto libxc_calloc(const int_type1 size1, const int_type2 size2){
+void* libxc_calloc(const int_type1 size1, const int_type2 size2){
   void * mem;
   cudaMallocManaged(&mem, size1*size2);
   cudaMemset(mem, 0, size1*size2);
diff --git a/src/work_mgga_inc.c b/src/work_mgga_inc.c
index 2c0d46629..591182732 100644
--- a/src/work_mgga_inc.c
+++ b/src/work_mgga_inc.c
@@ -114,7 +114,7 @@ WORK_MGGA(ORDER_TXT, SPIN_TXT)
         printf("Problem in the evaluation of the functional\n");
         if(p->nspin == XC_UNPOLARIZED){
           printf("./xc-get_data %d 1 ", p->info->number);
-          if(p->info->flags & (XC_FLAGS_NEEDS_LAPLACIAN | XC_FLAGS_NEEDS_TAU))
+          if(p->info->flags & (XC_FLAGS_NEEDS_LAPLACIAN))
             printf("%le 0.0 %le 0.0 0.0 %le 0.0 %le 0.0\n",
                    VAR(rho, ip, 0), VAR(sigma, ip, 0), VAR(lapl, ip, 0), VAR(tau, ip, 0));
           else if(p->info->flags & XC_FLAGS_NEEDS_LAPLACIAN)
@@ -167,26 +167,22 @@ WORK_MGGA_GPU(ORDER_TXT, SPIN_TXT)
     /* sanity check of input parameters */
     my_rho[0] = m_max(p->dens_threshold, rho[0]);
     /* Many functionals shamelessly divide by tau, so we set a reasonable threshold */
-    if(p->info->flags & XC_FLAGS_NEEDS_TAU)
-      my_tau[0] = m_max(p->tau_threshold, tau[0]);
+    my_tau[0] = m_max(p->tau_threshold, tau[0]);
     my_sigma[0] = m_max(p->sigma_threshold * p->sigma_threshold, sigma[0]);
 #ifdef XC_ENFORCE_FERMI_HOLE_CURVATURE
     /* The Fermi hole curvature 1 - xs^2/(8*ts) must be positive */
-    if(p->info->flags & XC_FLAGS_NEEDS_TAU)
-      my_sigma[0] = m_min(my_sigma[0], 8.0*my_rho[0]*my_tau[0]);
+    my_sigma[0] = m_min(my_sigma[0], 8.0*my_rho[0]*my_tau[0]);
 #endif
     /* lapl can have any values */
     if(p->nspin == XC_POLARIZED){
       double s_ave;
 
       my_rho[1]   = m_max(p->dens_threshold, rho[1]);
-      if(p->info->flags & XC_FLAGS_NEEDS_TAU)
-        my_tau[1] = m_max(p->tau_threshold, tau[1]);
+      my_tau[1] = m_max(p->tau_threshold, tau[1]);
       my_sigma[2] = m_max(p->sigma_threshold * p->sigma_threshold, sigma[2]);
 #ifdef XC_ENFORCE_FERMI_HOLE_CURVATURE
       /* The Fermi hole curvature 1 - xs^2/(8*ts) must be positive */
-      if(p->info->flags & XC_FLAGS_NEEDS_TAU)
-        my_sigma[2] = m_min(my_sigma[2], 8.0*my_rho[1]*my_tau[1]);
+      my_sigma[2] = m_min(my_sigma[2], 8.0*my_rho[1]*my_tau[1]);
 #endif
 
       my_sigma[1] = sigma[1];
