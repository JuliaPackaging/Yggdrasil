diff --git a/Couenne/src/bound_tightening/CouenneSparseBndVec.hpp b/Couenne/src/bound_tightening/CouenneSparseBndVec.hpp
index a63bbd1..5bd4cd4 100644
--- a/Couenne/src/bound_tightening/CouenneSparseBndVec.hpp
+++ b/Couenne/src/bound_tightening/CouenneSparseBndVec.hpp
@@ -64,9 +64,9 @@ namespace Couenne {
       size_ (src.size_),
       n_    (src.n_) {
 
-      for (register unsigned int i=0; i<n_; i++) {
+      for (unsigned int i=0; i<n_; i++) {
 
-	register unsigned int ind = (dInd_ [i] = src.dInd_ [i]);
+	unsigned int ind = (dInd_ [i] = src.dInd_ [i]);
 	data_ [ind] = src.data_ [ind];	
 	sInd_ [ind] = i; /// assert: src.sInd [ind] == i
       }
@@ -88,9 +88,9 @@ namespace Couenne {
     /// making sure it has been written. This should not happen to the
     /// end user as read operations are only performed on the dense
     /// structure, after this object has been populated.
-    T &operator[] (register unsigned int index) {
+    T &operator[] (unsigned int index) {
 
-      register unsigned int &sind = sInd_ [index];
+      unsigned int &sind = sInd_ [index];
 
       if ((sind >= n_) || 
 	  (dInd_ [sind] != index))
diff --git a/Couenne/src/bound_tightening/aggressiveBT.cpp b/Couenne/src/bound_tightening/aggressiveBT.cpp
index 178b526..936fdb4 100644
--- a/Couenne/src/bound_tightening/aggressiveBT.cpp
+++ b/Couenne/src/bound_tightening/aggressiveBT.cpp
@@ -34,17 +34,17 @@ namespace Bonmin {
 #define THRES_ABT_IMPROVED     0  // only continue ABT if at least these bounds have improved
 #define THRES_ABT_ORIG       100  // only do ABT on auxiliaries if they are less originals than this 
 
-static double distanceToBound (register int n, 
-			       register const double* xOrig,
-			       register const double* lower, 
-			       register const double* upper,
-			       register double cutoff_distance) { // stop if distance is above this
+static double distanceToBound (int n, 
+			       const double* xOrig,
+			       const double* lower, 
+			       const double* upper,
+			       double cutoff_distance) { // stop if distance is above this
 
-  register double Xdist = 0.;
+  double Xdist = 0.;
 
   for (; n--; ++upper, ++xOrig) {
 
-    register CouNumber diff = *lower++ - *xOrig;
+    CouNumber diff = *lower++ - *xOrig;
 
     if      ( diff                    > 0.) {if ((Xdist += diff) > cutoff_distance) break;}
     else if ((diff = *xOrig - *upper) > 0.) {if ((Xdist += diff) > cutoff_distance) break;}
diff --git a/Couenne/src/bound_tightening/operators/impliedBounds-exprSum.cpp b/Couenne/src/bound_tightening/operators/impliedBounds-exprSum.cpp
index c007309..8cc7f9f 100644
--- a/Couenne/src/bound_tightening/operators/impliedBounds-exprSum.cpp
+++ b/Couenne/src/bound_tightening/operators/impliedBounds-exprSum.cpp
@@ -117,11 +117,11 @@ bool exprSum::impliedBound (int wind, CouNumber *l, CouNumber *u, t_chg_bounds *
 
     exprGroup::lincoeff &lcoe = eg -> lcoeff ();
 
-    for (register exprGroup::lincoeff::iterator el = lcoe.begin ();
+    for (exprGroup::lincoeff::iterator el = lcoe.begin ();
 	 el != lcoe.end (); ++el) {
 
-      register CouNumber coe = el -> second;
-      register int       ind = el -> first -> Index ();
+      CouNumber coe = el -> second;
+      int       ind = el -> first -> Index ();
 
       if      (coe >  0.) {I1 [ipos] = ind; C1 [ipos++] = coe;}
       else if (coe < -0.) {I2 [ineg] = ind; C2 [ineg++] = coe;}
@@ -233,8 +233,8 @@ bool exprSum::impliedBound (int wind, CouNumber *l, CouNumber *u, t_chg_bounds *
 
   int maxind = -1;
 
-  for (register int i=ipos; i--; I1++) if (*I1 > maxind) maxind = *I1;
-  for (register int i=ineg; i--; I2++) if (*I2 > maxind) maxind = *I2;
+  for (int i=ipos; i--; I1++) if (*I1 > maxind) maxind = *I1;
+  for (int i=ineg; i--; I2++) if (*I2 > maxind) maxind = *I2;
 
   I1 -= ipos;
   I2 -= ineg;
@@ -251,7 +251,7 @@ bool exprSum::impliedBound (int wind, CouNumber *l, CouNumber *u, t_chg_bounds *
     // All finite bounds. All var. bounds can be tightened.
 
     // tighten upper bound of variables in I1
-    for (register int i=ipos; i--;) {
+    for (int i=ipos; i--;) {
       int ind = I1 [i];
       if ((tighter = (updateBound (+1, u + ind, (wu - lower) / C1 [i] + lc [ind]) || tighter))) {
 	chg [ind].setUpper(t_chg_bounds::CHANGED);
@@ -261,7 +261,7 @@ bool exprSum::impliedBound (int wind, CouNumber *l, CouNumber *u, t_chg_bounds *
     }
 
     // tighten lower bound of variables in I2
-    for (register int i=ineg; i--;) {
+    for (int i=ineg; i--;) {
       int ind = I2 [i];
       if ((tighter = (updateBound (-1, l + ind, (wu - lower) / C2 [i] + uc [ind]) || tighter))) {
 	chg [ind].setLower(t_chg_bounds::CHANGED);
@@ -294,7 +294,7 @@ bool exprSum::impliedBound (int wind, CouNumber *l, CouNumber *u, t_chg_bounds *
   if ((infUp1 == -1) && (infLo2 == -1) && (wl > -COUENNE_INFINITY / 1e10)) { 
     // All finite bounds. All var. bounds can be tightened.
 
-    for (register int i=ipos; i--;) {
+    for (int i=ipos; i--;) {
       int ind = I1 [i];
       if ((tighter = (updateBound (-1, l + ind, (wl - upper) / C1 [i] + uc [ind]) || tighter))) {
 	chg [ind].setLower(t_chg_bounds::CHANGED); 
@@ -303,7 +303,7 @@ bool exprSum::impliedBound (int wind, CouNumber *l, CouNumber *u, t_chg_bounds *
       }
     }
 
-    for (register int i=ineg; i--;) {
+    for (int i=ineg; i--;) {
       int ind = I2 [i];
       if ((tighter = (updateBound (+1, u + ind, (wl - upper) / C2 [i] + lc [ind]) || tighter))) {
 	chg [ind].setUpper(t_chg_bounds::CHANGED);
@@ -352,7 +352,7 @@ static CouNumber scanBounds (int        num,      /// cardinality of the set (I1
                                                   /// bound, or -2 if more than one exist
   CouNumber bound = 0.;
 
-  for (register int i = num; i--;) {
+  for (int i = num; i--;) {
 
     CouNumber bd = bounds [indices [i]];
 
diff --git a/Couenne/src/bound_tightening/twoImpliedBT/TwoImpliedGenCuts.cpp b/Couenne/src/bound_tightening/twoImpliedBT/TwoImpliedGenCuts.cpp
index f61a96c..620279e 100644
--- a/Couenne/src/bound_tightening/twoImpliedBT/TwoImpliedGenCuts.cpp
+++ b/Couenne/src/bound_tightening/twoImpliedBT/TwoImpliedGenCuts.cpp
@@ -312,7 +312,7 @@ void CouenneTwoImplied::generateCuts (const OsiSolverInterface &si,
 	if (CoinCpuTime () > problem_ -> getMaxCpuTime ())
 	  break;
 
-	register int 
+	int 
 	  indj = ind [j],
 	  indk = ind [k];
 
diff --git a/Couenne/src/bound_tightening/twoImpliedBT/TwoImpliedIneqCombine.cpp b/Couenne/src/bound_tightening/twoImpliedBT/TwoImpliedIneqCombine.cpp
index eb78445..9413b7b 100644
--- a/Couenne/src/bound_tightening/twoImpliedBT/TwoImpliedIneqCombine.cpp
+++ b/Couenne/src/bound_tightening/twoImpliedBT/TwoImpliedIneqCombine.cpp
@@ -39,10 +39,10 @@ typedef struct {
 
 // compare two threshold values ///////////////////////////////////
 
-int compthres (register const void *t1, 
-	       register const void *t2) {
+int compthres (const void *t1, 
+	       const void *t2) {
 
-  register double
+  double
     a1 = (*(threshold **) t1) -> alpha,
     a2 = (*(threshold **) t2) -> alpha;
 
@@ -60,10 +60,10 @@ struct indPosPair {
 
 // compare two pairs (index,value) ///////////////////////////////////
 
-int compPair (register const void *p1, 
-	      register const void *p2) {
+int compPair (const void *p1, 
+	      const void *p2) {
 
-  register int
+  int
     i1 = ((struct indPosPair *) p1) -> index,
     i2 = ((struct indPosPair *) p2) -> index;
 
@@ -660,7 +660,7 @@ attempting newU = ((u1 - u2 - (minSum1 - minSum2) + (subMin1 - subMin2)) * alpha
 	  printf ("    swap'em: %g, %g\n", newL, newU);
 #endif
 
-	  register double tmp = newL <= - COUENNE_INFINITY / 10 ?   COUENNE_INFINITY : newL;
+	  double tmp = newL <= - COUENNE_INFINITY / 10 ?   COUENNE_INFINITY : newL;
 	  newL                = newU >=   COUENNE_INFINITY / 10 ? - COUENNE_INFINITY : newU;
 	  newU                = tmp;
 	}
diff --git a/Couenne/src/branch/feasibleRegion.cpp b/Couenne/src/branch/feasibleRegion.cpp
index 6f20c7c..a25f89d 100644
--- a/Couenne/src/branch/feasibleRegion.cpp
+++ b/Couenne/src/branch/feasibleRegion.cpp
@@ -63,7 +63,7 @@ double CouenneObject::feasibleRegion (OsiSolverInterface *solver,
       expression ** args = expr -> ArgList ();
       int nargs = expr -> nArgs ();
 
-      for (register int i=0; i < nargs; i++) {
+      for (int i=0; i < nargs; i++) {
 
 	if ((index = args [i] -> Index()) >= 0) {
 	  val = info -> solution_ [index];
diff --git a/Couenne/src/branch/projections.cpp b/Couenne/src/branch/projections.cpp
index 53ed173..e1b0cbf 100644
--- a/Couenne/src/branch/projections.cpp
+++ b/Couenne/src/branch/projections.cpp
@@ -25,7 +25,7 @@ CouNumber project (CouNumber a, CouNumber b, CouNumber c,
 		   CouNumber *xp, CouNumber *yp) {
 
   /* compute projection of (x0,y0) onto line ax+by+c=0 */
-  register CouNumber
+  CouNumber
     t  = - (a*x0 + b*y0 + c);
 
   /* projection coordinates */
diff --git a/Couenne/src/convex/generateCuts.cpp b/Couenne/src/convex/generateCuts.cpp
index 1b3016d..395fa1e 100644
--- a/Couenne/src/convex/generateCuts.cpp
+++ b/Couenne/src/convex/generateCuts.cpp
@@ -73,7 +73,7 @@ void sparse2dense (int ncols, t_chg_bounds *chg_bds, int *&changed, int &nchange
   changed  = (int *) realloc (changed, ncols * sizeof (int));
   nchanged = 0;
 
-  for (register int i=ncols, j=0; i--; j++, chg_bds++)
+  for (int i=ncols, j=0; i--; j++, chg_bds++)
     if (chg_bds -> lower() != t_chg_bounds::UNCHANGED ||
 	chg_bds -> upper() != t_chg_bounds::UNCHANGED ) {
       *changed++ = j;
diff --git a/Couenne/src/convex/isOptimumCut.cpp b/Couenne/src/convex/isOptimumCut.cpp
index 16a011d..8f70cfe 100644
--- a/Couenne/src/convex/isOptimumCut.cpp
+++ b/Couenne/src/convex/isOptimumCut.cpp
@@ -37,8 +37,8 @@ bool isOptimumCut (const CouNumber *opt, OsiCuts &cs, CouenneProblem *p) {
       const double *lvalues  = lbs.getElements ();
 
       for (int j = lbs.getNumElements (); j--;) {
-	register double lb  = *lvalues++;
-	register int    ind = *lindices++;
+	double lb  = *lvalues++;
+	int    ind = *lindices++;
 
 	if (lb > opt [ind] + COUENNE_EPS) {
 	  printf ("################################## new lb [%d] = %g cuts opt %g by %g\n",
@@ -54,8 +54,8 @@ bool isOptimumCut (const CouNumber *opt, OsiCuts &cs, CouenneProblem *p) {
       const double *uvalues  = ubs.getElements ();
 
       for (int j = ubs.getNumElements (); j--;) {
-	register double ub  = *uvalues++;
-	register int    ind = *uindices++;
+	double ub  = *uvalues++;
+	int    ind = *uindices++;
 
 	if (ub < opt [ind] - COUENNE_EPS) {
 	  printf ("################################## new ub [%d] = %g cuts opt %g by %g\n",
diff --git a/Couenne/src/convex/operators/conv-exprGroup.cpp b/Couenne/src/convex/operators/conv-exprGroup.cpp
index 5a4801a..9d73fdd 100644
--- a/Couenne/src/convex/operators/conv-exprGroup.cpp
+++ b/Couenne/src/convex/operators/conv-exprGroup.cpp
@@ -80,7 +80,7 @@ void exprGroup::getBounds (expression *&lb, expression *&ub) {
 //   // count linear and constant terms
 //   int nlin = lcoeff_.size();
 //   if (fabs (c0_) > COUENNE_EPS) nlin++;
-//   //  for (register int *ind = index_; *ind++>=0; nlin++);
+//   //  for (int *ind = index_; *ind++>=0; nlin++);
 
 //   expression 
 //     **linall = new expression * [nlin + 1], // linear arglist for lower bound
diff --git a/Couenne/src/convex/operators/conv-exprInv.cpp b/Couenne/src/convex/operators/conv-exprInv.cpp
index 84b4e7d..32d1991 100644
--- a/Couenne/src/convex/operators/conv-exprInv.cpp
+++ b/Couenne/src/convex/operators/conv-exprInv.cpp
@@ -54,7 +54,7 @@ void exprInv::getBounds (expression *&lb, expression *&ub) {
 // compute VALUE of lower and upper bound of expression
 void exprInv::getBounds (CouNumber &lb, CouNumber &ub) {
 
-  register CouNumber lba, uba;
+  CouNumber lba, uba;
 
   argument_ -> getBounds (lba, uba);
 
diff --git a/Couenne/src/convex/operators/conv-exprMul-reformulate.cpp b/Couenne/src/convex/operators/conv-exprMul-reformulate.cpp
index ac41c8c..1e7b6c5 100644
--- a/Couenne/src/convex/operators/conv-exprMul-reformulate.cpp
+++ b/Couenne/src/convex/operators/conv-exprMul-reformulate.cpp
@@ -26,7 +26,7 @@ using namespace Couenne;
 
 inline bool areSameVariables (expression *v1, expression *v2) {
 
-  register int t1 = v1 -> Type (), t2;
+  int t1 = v1 -> Type (), t2;
   return (((t1 == VAR) || (t1 == AUX)) &&
 	  (((t2 = v2 -> Type ()) == VAR) || (t2 == AUX)) && 
 	  (v1 -> Index () == v2 -> Index ()));
diff --git a/Couenne/src/convex/operators/conv-exprTrilinear.cpp b/Couenne/src/convex/operators/conv-exprTrilinear.cpp
index 965851e..429fb90 100644
--- a/Couenne/src/convex/operators/conv-exprTrilinear.cpp
+++ b/Couenne/src/convex/operators/conv-exprTrilinear.cpp
@@ -69,7 +69,7 @@ void exprTrilinear::getBounds (CouNumber &lb, CouNumber &ub) {
     for   (int i1 = 0; i1 < 2; i1++)
       for (int i2 = 0; i2 < 2; i2++) {
 
-	register double curbound = 
+	double curbound = 
 	  (i0 ? ubA [0] : lbA [0]) * 
 	  (i1 ? ubA [1] : lbA [1]) *
 	  (i2 ? ubA [2] : lbA [2]);
diff --git a/Couenne/src/convex/operators/exprMul-upperHull.cpp b/Couenne/src/convex/operators/exprMul-upperHull.cpp
index 7f36042..5becd97 100644
--- a/Couenne/src/convex/operators/exprMul-upperHull.cpp
+++ b/Couenne/src/convex/operators/exprMul-upperHull.cpp
@@ -30,9 +30,9 @@ int genMulCoeff (CouNumber x1, CouNumber y1,
 
 
 // invert interval bounds and current point
-inline void invertInterval (register double &l, register double &u, register double x) {
+inline void invertInterval (double &l, double &u, double x) {
 
-  register double tmp = l; 
+  double tmp = l; 
   l = -u; 
   u = -tmp;
 
diff --git a/Couenne/src/convex/operators/powNewton.cpp b/Couenne/src/convex/operators/powNewton.cpp
index 7212167..212a916 100644
--- a/Couenne/src/convex/operators/powNewton.cpp
+++ b/Couenne/src/convex/operators/powNewton.cpp
@@ -44,7 +44,7 @@ CouNumber powNewton (CouNumber xc, CouNumber yc,
   //
   // x(k+1) = x(k) - F(x(k))/F'(x(k))
 
-  register CouNumber xk = xc;
+  CouNumber xk = xc;
 
   CouNumber fk  = f (xk) - yc,
             fpk = fp (xk),
@@ -87,7 +87,7 @@ CouNumber powNewton (CouNumber xc, CouNumber yc, funtriplet *tri) {
   //
   // x(k+1) = x(k) - f(x(k))/f'(x(k))
 
-  register CouNumber xk = xc;
+  CouNumber xk = xc;
 
   CouNumber fk  = tri -> F (xk) - yc,
             fpk = tri -> Fp (xk),
@@ -111,17 +111,17 @@ CouNumber powNewton (CouNumber xc, CouNumber yc, funtriplet *tri) {
 #else
 
 /// the operator itself
-inline CouNumber inv (register CouNumber arg) 
+inline CouNumber inv (CouNumber arg) 
 {return 1.0 / arg;}
 
 
 /// derivative of inv (x)
-inline CouNumber oppInvSqr (register CouNumber x) 
+inline CouNumber oppInvSqr (CouNumber x) 
 {return (- inv (x*x));}
 
 
 /// inv_dblprime, second derivative of inv (x)
-inline CouNumber inv_dblprime (register CouNumber x) 
+inline CouNumber inv_dblprime (CouNumber x) 
 {return (2 * inv (x*x*x));}
 
 
@@ -138,7 +138,7 @@ int main (int argc, char **argv) {
 
   //expon = atof (argv [1]);
 
-  for (register int i=1; i--;)
+  for (int i=1; i--;)
     r = powNewton (xc, yc, f, fp, fpp);
 
   printf ("xc = %.14f: xk = %.15f, slope %.15f -- %.15f ==> [%.15f = -1?]\n", 
diff --git a/Couenne/src/convex/operators/trigNewton.cpp b/Couenne/src/convex/operators/trigNewton.cpp
index 4336555..207fa8f 100644
--- a/Couenne/src/convex/operators/trigNewton.cpp
+++ b/Couenne/src/convex/operators/trigNewton.cpp
@@ -29,12 +29,12 @@ CouNumber trigNewton (CouNumber a, CouNumber l, CouNumber u) {
   // F'(x) = - sin x - cos x / (x-a) + (sin x - sin a) / (x - a)^2
 
   if (l>u) {
-    register CouNumber swap = l;
+    CouNumber swap = l;
     l = u;
     u = swap;
   }
 
-  register CouNumber xk = 0.5 * (u+l);
+  CouNumber xk = 0.5 * (u+l);
 
   CouNumber sina  = sin (a),
             sinxk = sin (xk),
@@ -45,7 +45,7 @@ CouNumber trigNewton (CouNumber a, CouNumber l, CouNumber u) {
             F     = cosxk - dydx;
 
   // Newton loop. Tolerance is set above
-  for (register int k = MAX_ITER; (fabs (F) > COU_TRIG_TOLERANCE) && k--;) {
+  for (int k = MAX_ITER; (fabs (F) > COU_TRIG_TOLERANCE) && k--;) {
 
     CouNumber Fp = sinxk + (cosxk - dydx) / dx;
 
@@ -74,7 +74,7 @@ int main (int argc, char **argv) {
             l = atof (argv [2]),
             u = atof (argv [3]), r;
 
-  for (register int i=100000; i--;)
+  for (int i=100000; i--;)
     r = trigNewton (a, l, u);
 
   printf ("b0 = %.14f: slope %.15f, derivative %.15f\n", 
diff --git a/Couenne/src/cut/sdpcuts/CouenneMatrix.cpp b/Couenne/src/cut/sdpcuts/CouenneMatrix.cpp
index 0ee8ddb..ccc64d4 100644
--- a/Couenne/src/cut/sdpcuts/CouenneMatrix.cpp
+++ b/Couenne/src/cut/sdpcuts/CouenneMatrix.cpp
@@ -21,7 +21,7 @@ using namespace Couenne;
 // copy constructor
 CouenneSparseVector::CouenneSparseVector (const CouenneSparseVector &rhs) {
 
-  for (register std::set <CouenneScalar *, CouenneSparseVector::compare_scalars>::const_iterator 
+  for (std::set <CouenneScalar *, CouenneSparseVector::compare_scalars>::const_iterator 
 	 i  = rhs. elem_. begin ();
        i   != rhs. elem_. end   (); ++i)
 
@@ -32,7 +32,7 @@ CouenneSparseVector::CouenneSparseVector (const CouenneSparseVector &rhs) {
 // assignment operator
 CouenneSparseVector &CouenneSparseVector::operator= (const CouenneSparseVector &rhs) {
 
-  for (register std::set <CouenneScalar *, CouenneSparseVector::compare_scalars>::const_iterator 
+  for (std::set <CouenneScalar *, CouenneSparseVector::compare_scalars>::const_iterator 
 	 i  = rhs. elem_. begin ();
        i   != rhs. elem_. end   (); ++i)
 
@@ -125,7 +125,7 @@ double CouenneSparseVector::multiply_thres (const CouenneSparseVector &v2, doubl
 
   double prod = 0.;
 
-  for (register std::set <CouenneScalar *, CouenneSparseVector::compare_scalars>::const_iterator 
+  for (std::set <CouenneScalar *, CouenneSparseVector::compare_scalars>::const_iterator 
 	 i1 =    elem_. begin (),
 	 i2 = v2.elem_. begin ();
 
@@ -212,7 +212,7 @@ CouenneExprMatrix::~CouenneExprMatrix () {
 /// Destructor
 CouenneSparseVector::~CouenneSparseVector () {
 
-  for (register std::set <CouenneScalar *, CouenneSparseVector::compare_scalars>::iterator 
+  for (std::set <CouenneScalar *, CouenneSparseVector::compare_scalars>::iterator 
 	 i  = elem_. begin ();
        i   != elem_. end   (); ++i)
     delete (*i);
diff --git a/Couenne/src/cut/sdpcuts/CouenneMatrix.hpp b/Couenne/src/cut/sdpcuts/CouenneMatrix.hpp
index 74666ed..e723352 100644
--- a/Couenne/src/cut/sdpcuts/CouenneMatrix.hpp
+++ b/Couenne/src/cut/sdpcuts/CouenneMatrix.hpp
@@ -68,8 +68,8 @@ namespace Couenne {
   public:
 
     struct compare_scalars {
-      inline bool operator() (register CouenneScalar * const &a, 
-			      register CouenneScalar * const &b)
+      inline bool operator() (CouenneScalar * const &a, 
+			      CouenneScalar * const &b)
       {return a -> getIndex () < b -> getIndex ();}
     };
 
@@ -106,8 +106,8 @@ namespace Couenne {
   public:
 
     struct compare_pair_ind {
-      inline bool operator() (register const std::pair <int, CouenneSparseVector *> &a, 
-			      register const std::pair <int, CouenneSparseVector *> &b) const
+      inline bool operator() (const std::pair <int, CouenneSparseVector *> &a, 
+			      const std::pair <int, CouenneSparseVector *> &b) const
       {return a. first < b. first;}
     };
 
diff --git a/Couenne/src/cut/sdpcuts/CutGenSparse.cpp b/Couenne/src/cut/sdpcuts/CutGenSparse.cpp
index 47523e1..3def0b9 100644
--- a/Couenne/src/cut/sdpcuts/CutGenSparse.cpp
+++ b/Couenne/src/cut/sdpcuts/CutGenSparse.cpp
@@ -229,11 +229,11 @@ void CouenneSdpCuts::additionalSDPcuts (const OsiSolverInterface &si,
 
   double *subA = new double [cnt*cnt];
 
-  for (register int i=0, k=0; i<n; i++)
+  for (int i=0, k=0; i<n; i++)
 
     if (indices [i] >= 0) {
       
-      for (register int j=0, k2 = 0; j<n; j++)
+      for (int j=0, k2 = 0; j<n; j++)
 
 	if (indices [j] >= 0) {
 	  subA [cnt * k  + k2] = 
diff --git a/Couenne/src/disjunctive/CouenneDisjCuts.hpp b/Couenne/src/disjunctive/CouenneDisjCuts.hpp
index 0b5b2d2..0d93b63 100644
--- a/Couenne/src/disjunctive/CouenneDisjCuts.hpp
+++ b/Couenne/src/disjunctive/CouenneDisjCuts.hpp
@@ -191,19 +191,19 @@ protected:
 
 
 /// invert all contents
-inline void CoinInvN (register const double *orig, 
-		      register int n, 
-		      register double *inverted) {
+inline void CoinInvN (const double *orig, 
+		      int n, 
+		      double *inverted) {
 
   while (n--) *inverted++ = - *orig++;
 }
 
 
 /// a CoinCopyN with a += on each element
-inline void CoinCopyDisp (register const int *src, 
-			  register int num, 
-			  register int *dst, 
-			  register int displacement) {
+inline void CoinCopyDisp (const int *src, 
+			  int num, 
+			  int *dst, 
+			  int displacement) {
   while (num--)
     *dst++ = *src++ + displacement;
 }
diff --git a/Couenne/src/disjunctive/disjCut.cpp b/Couenne/src/disjunctive/disjCut.cpp
index 3a4756b..8d4353e 100644
--- a/Couenne/src/disjunctive/disjCut.cpp
+++ b/Couenne/src/disjunctive/disjCut.cpp
@@ -257,7 +257,7 @@ int CouenneDisjCuts::generateDisjCuts (std::vector <std::pair <OsiCuts *, OsiCut
       // count nonzero entries, compute ratio max/min coefficient
       double mincoeff = COIN_DBL_MAX, maxcoeff = 0.;
 
-      for (register int i=n+1; i--;) {
+      for (int i=n+1; i--;) {
 	double value = fabs (AlphaBeta [i]);
 	if (value == 0.) continue;
 	if (value > maxcoeff) maxcoeff = value;
@@ -361,7 +361,7 @@ int CouenneDisjCuts::generateDisjCuts (std::vector <std::pair <OsiCuts *, OsiCut
 
     // remove last ncolLeft + ncolRight columns from cglp
     int *delIndices = new int [ncolLeft + ncolRight];
-    for (register int nc = ncolLeft + ncolRight, j = N + nc; nc--;)
+    for (int nc = ncolLeft + ncolRight, j = N + nc; nc--;)
       *delIndices++ = --j;
     delIndices -= (ncolLeft + ncolRight);
     cglp.deleteCols (ncolLeft + ncolRight, delIndices);
diff --git a/Couenne/src/disjunctive/singleDisjunctions.cpp b/Couenne/src/disjunctive/singleDisjunctions.cpp
index 29a87ea..1d8087e 100644
--- a/Couenne/src/disjunctive/singleDisjunctions.cpp
+++ b/Couenne/src/disjunctive/singleDisjunctions.cpp
@@ -71,8 +71,8 @@ int CouenneDisjCuts::checkDisjSide (OsiSolverInterface &si, OsiCuts *cuts) const
     const double *lvalues  = lbs.getElements ();
 
     for (int j = lbs.getNumElements (); j--;) {
-      register double lb  = *lvalues++;
-      register int    ind = *lindices++;
+      double lb  = *lvalues++;
+      int    ind = *lindices++;
 
       if (lb > upper [ind] + COUENNE_EPS) // fathom node
 	return COUENNE_INFEASIBLE;
@@ -88,8 +88,8 @@ int CouenneDisjCuts::checkDisjSide (OsiSolverInterface &si, OsiCuts *cuts) const
     const double *uvalues  = ubs.getElements ();
 
     for (int j = ubs.getNumElements (); j--;) {
-      register double ub  = *uvalues++;
-      register int    ind = *uindices++;
+      double ub  = *uvalues++;
+      int    ind = *uindices++;
 
       if (ub < lower [ind] - COUENNE_EPS) // fathom node
 	return COUENNE_INFEASIBLE;
@@ -163,7 +163,7 @@ void CouenneDisjCuts::mergeBoxes (int dir, // direction (negative for "<", posit
 
     for (;;) {
 
-      register int diff = *Li - *Ri;
+      int diff = *Li - *Ri;
 
       if      (diff < 0) {if (!--Ln) break; Li++; Le++;}
       else if (diff > 0) {if (!--Rn) break; Ri++; Re++;}
diff --git a/Couenne/src/expression/CouenneDomain.hpp b/Couenne/src/expression/CouenneDomain.hpp
index b2667a3..b149682 100644
--- a/Couenne/src/expression/CouenneDomain.hpp
+++ b/Couenne/src/expression/CouenneDomain.hpp
@@ -81,9 +81,9 @@ public:
   /// return dimension_
   inline int Dimension () {return dimension_;}
 
-  inline CouNumber &x  (register int index) {return x_  [index];} ///< return current variable
-  inline CouNumber &lb (register int index) {return lb_ [index];} ///< return current lower bound
-  inline CouNumber &ub (register int index) {return ub_ [index];} ///< return current upper bound
+  inline CouNumber &x  (int index) {return x_  [index];} ///< return current variable
+  inline CouNumber &lb (int index) {return lb_ [index];} ///< return current lower bound
+  inline CouNumber &ub (int index) {return ub_ [index];} ///< return current upper bound
 
   inline CouNumber *x  () {return x_ ;} ///< return current variable vector
   inline CouNumber *lb () {return lb_;} ///< return current lower bound vector
@@ -153,9 +153,9 @@ public:
 
   inline DomainPoint *current ()   {return point_;}                          ///< return current point
 
-  inline CouNumber &x  (register int index) {return point_ -> x  (index);}   ///< current variable
-  inline CouNumber &lb (register int index) {return point_ -> lb (index);}   ///< current lower bound
-  inline CouNumber &ub (register int index) {return point_ -> ub (index);}   ///< current upper bound
+  inline CouNumber &x  (int index) {return point_ -> x  (index);}   ///< current variable
+  inline CouNumber &lb (int index) {return point_ -> lb (index);}   ///< current lower bound
+  inline CouNumber &ub (int index) {return point_ -> ub (index);}   ///< current upper bound
 
   inline CouNumber *x  () {return point_ -> x  ();}   ///< return current variable vector
   inline CouNumber *lb () {return point_ -> lb ();}   ///< return current lower bound vector
diff --git a/Couenne/src/expression/CouenneExprAux.hpp b/Couenne/src/expression/CouenneExprAux.hpp
index 4ff247c..ce6d16e 100644
--- a/Couenne/src/expression/CouenneExprAux.hpp
+++ b/Couenne/src/expression/CouenneExprAux.hpp
@@ -156,7 +156,7 @@ class exprAux: public exprVar {
     if (isDefinedInteger ()) 
       return true;
 
-    register CouNumber l = lb ();
+    CouNumber l = lb ();
     return ((l == ub ()) && (COUENNE_round (l) == l));
     //CouNumber l = (*(Lb ())) ();
     //return (::isInteger (l) && (fabs (l - (*(Ub ())) ()) < COUENNE_EPS));
diff --git a/Couenne/src/expression/CouenneExprOp.hpp b/Couenne/src/expression/CouenneExprOp.hpp
index b9199de..f0d5726 100644
--- a/Couenne/src/expression/CouenneExprOp.hpp
+++ b/Couenne/src/expression/CouenneExprOp.hpp
@@ -97,7 +97,7 @@ class exprOp: public expression {
   expression **clonearglist (Domain *d = NULL) const {
     if (nargs_) {
       expression **al = new expression * [nargs_];
-      for (register int i=0; i<nargs_; i++)
+      for (int i=0; i<nargs_; i++)
 	al [i] = arglist_ [i] -> clone (d);
       return al;
     } else return NULL;
diff --git a/Couenne/src/expression/CouenneExpression.hpp b/Couenne/src/expression/CouenneExpression.hpp
index d4a8299..9e0fdbf 100644
--- a/Couenne/src/expression/CouenneExpression.hpp
+++ b/Couenne/src/expression/CouenneExpression.hpp
@@ -276,9 +276,9 @@ class expression {
 
 /// updates maximum violation. Used with all impliedBound. Returns true
 /// if a bound has been modified, false otherwise
-inline bool updateBound (register int sign, 
-			 register CouNumber *dst, 
-			 register CouNumber src) {
+inline bool updateBound (int sign, 
+			 CouNumber *dst, 
+			 CouNumber src) {
 
   // meaning: 
   //
@@ -288,7 +288,7 @@ inline bool updateBound (register int sign,
   // that is, sign > 0 means we are tightening an UPPER bound
   //          sign < 0                            LOWER
 
-  register double delta = (sign > 0) ? (*dst - src) : (src - *dst);
+  double delta = (sign > 0) ? (*dst - src) : (src - *dst);
 
   if (delta > 0.) {
     //printf ("%.12g --> %.12g\n", *dst, src);
diff --git a/Couenne/src/expression/domain.cpp b/Couenne/src/expression/domain.cpp
index 642d77d..fcb3fd5 100644
--- a/Couenne/src/expression/domain.cpp
+++ b/Couenne/src/expression/domain.cpp
@@ -213,20 +213,20 @@ void Domain::push (const OsiSolverInterface *si,
 
       OsiColCut *cut = cs -> colCutPtr (i);
 
-      register const CoinPackedVector
+      const CoinPackedVector
 	&lbs = cut -> lbs (),
 	&ubs = cut -> ubs ();
 
-      register const int    *indices  = lbs. getIndices ();
-      register const double *elements = lbs. getElements ();
+      const int    *indices  = lbs. getIndices ();
+      const double *elements = lbs. getElements ();
 
-      register CouNumber
+      CouNumber
 	*lb = point_ -> lb_,
 	*ub = point_ -> ub_;
 
       // copy lbs
 
-      for (register int j = lbs. getNumElements (); j--; elements++, indices++)
+      for (int j = lbs. getNumElements (); j--; elements++, indices++)
 	if (*elements > lb [*indices])
 	  lb [*indices] = *elements;
 
@@ -235,7 +235,7 @@ void Domain::push (const OsiSolverInterface *si,
       indices  = ubs. getIndices ();
       elements = ubs. getElements ();
 
-      for (register int j = ubs. getNumElements (); j--; elements++, indices++)
+      for (int j = ubs. getNumElements (); j--; elements++, indices++)
 	if (*elements < ub [*indices])
 	  ub [*indices] = *elements;
     }
diff --git a/Couenne/src/expression/exprOp.cpp b/Couenne/src/expression/exprOp.cpp
index 965bb4e..72a4212 100644
--- a/Couenne/src/expression/exprOp.cpp
+++ b/Couenne/src/expression/exprOp.cpp
@@ -81,7 +81,7 @@ int exprOp::compare (exprOp &e1) {
   if (nargs_ > e1.nargs_) return  1;
 
   // not an exprGroup, compare arguments
-  for (register int i = nargs_; i--;) {
+  for (int i = nargs_; i--;) {
 
     int res = arglist_ [i] -> compare (*(e1. ArgList () [i]));
     if (res) return res;
@@ -161,7 +161,7 @@ void exprOp::replace (exprVar *x, exprVar *w) {
   expression **al = arglist_;
   int index = x -> Index ();
 
-  for (register int i = nargs_; i--; al++)
+  for (int i = nargs_; i--; al++)
 
     switch ((*al) -> Type ()) {
 
@@ -299,7 +299,7 @@ expression *exprOp:: simplify () {
 
 int exprOp::shrink_arglist (CouNumber c, CouNumber null_element) {
 
-  register int i=0, j=0;
+  int i=0, j=0;
 
   bool one_fun = false;
 
@@ -312,7 +312,7 @@ int exprOp::shrink_arglist (CouNumber c, CouNumber null_element) {
     return 0;
 
   // check if there is at least one non-constant expression
-  for (register int k=nargs_; k--;) 
+  for (int k=nargs_; k--;) 
     if (arglist_ [k]) {
       one_fun = true;
       break;
diff --git a/Couenne/src/expression/exprUnary.cpp b/Couenne/src/expression/exprUnary.cpp
index 4b60573..b1ef0e7 100644
--- a/Couenne/src/expression/exprUnary.cpp
+++ b/Couenne/src/expression/exprUnary.cpp
@@ -89,7 +89,7 @@ bool exprUnary::isInteger () {
       (au <  COUENNE_INFINITY) &&
       fabs (al - au) < COUENNE_EPS) { // argument is constant
 
-    register CouNumber fval = (F ()) (al); 
+    CouNumber fval = (F ()) (al); 
 
     // check if f(lb=ub) is integer
     if (fabs (COUENNE_round (fval) - fval) < COUENNE_EPS)
@@ -103,7 +103,7 @@ bool exprUnary::isInteger () {
 // simplify unary operators
 expression *exprUnary:: simplify () {
 
-  register expression *subst;
+  expression *subst;
 
   // Simplify argument g(x) of this expression f(g(x))
   if ((subst = argument_ -> simplify ())) {
diff --git a/Couenne/src/expression/expression.cpp b/Couenne/src/expression/expression.cpp
index cc0bff2..527741d 100644
--- a/Couenne/src/expression/expression.cpp
+++ b/Couenne/src/expression/expression.cpp
@@ -63,7 +63,7 @@ void exprConst::generateCuts (expression *w, //const OsiSolverInterface &si,
 /// compare generic expression with other expression
 int expression::compare (expression &e1) {
 
-  register int c0 =     code (),
+  int c0 =     code (),
                c1 = e1. code ();
 
   if      (c0 < c1) return -1;
@@ -90,7 +90,7 @@ int expression::compare (expression &e1) {
   // expressions are both variables or constants
 
   {
-    register int 
+    int 
       i0 =     Index (),
       i1 = e1. Index ();
 
@@ -101,7 +101,7 @@ int expression::compare (expression &e1) {
 
   // both are numbers
   {
-    register CouNumber 
+    CouNumber 
       v0 =     Value (), 
       v1 = e1. Value ();
 
diff --git a/Couenne/src/expression/operators/CouenneExprDiv.hpp b/Couenne/src/expression/operators/CouenneExprDiv.hpp
index 1587688..2f481a8 100644
--- a/Couenne/src/expression/operators/CouenneExprDiv.hpp
+++ b/Couenne/src/expression/operators/CouenneExprDiv.hpp
@@ -121,7 +121,7 @@ inline CouNumber exprDiv::operator () ()
 /// check if bounding box is suitable for a multiplication/division
 /// convexification constraint
 
-inline bool is_boundbox_regular (register CouNumber b1, register CouNumber b2) {
+inline bool is_boundbox_regular (CouNumber b1, CouNumber b2) {
 
   // Why SAFE_COEFFICIENT and not COUENNE_INFINITY? Because
   // OsiRowCut::set[LU]b do not work for values more than
diff --git a/Couenne/src/expression/operators/CouenneExprInv.hpp b/Couenne/src/expression/operators/CouenneExprInv.hpp
index 5166d9f..6e65146 100644
--- a/Couenne/src/expression/operators/CouenneExprInv.hpp
+++ b/Couenne/src/expression/operators/CouenneExprInv.hpp
@@ -16,17 +16,17 @@
 namespace Couenne {
 
 /// the operator itself
-inline CouNumber inv (register CouNumber arg) 
+inline CouNumber inv (CouNumber arg) 
 {return 1. / arg;}
 
 
 /// derivative of inv (x)
-inline CouNumber oppInvSqr (register CouNumber x) 
+inline CouNumber oppInvSqr (CouNumber x) 
 {return (- inv (x*x));}
 
 
 /// inv_dblprime, second derivative of inv (x)
-inline CouNumber inv_dblprime (register CouNumber x) 
+inline CouNumber inv_dblprime (CouNumber x) 
 {return (2 * inv (x*x*x));}
 
 
diff --git a/Couenne/src/expression/operators/CouenneExprOpp.hpp b/Couenne/src/expression/operators/CouenneExprOpp.hpp
index 43b7f7b..6df3f73 100644
--- a/Couenne/src/expression/operators/CouenneExprOpp.hpp
+++ b/Couenne/src/expression/operators/CouenneExprOpp.hpp
@@ -18,7 +18,7 @@ namespace Couenne {
 
 /// operator opp: returns the opposite of a number
 
-inline CouNumber opp (register CouNumber arg) 
+inline CouNumber opp (CouNumber arg) 
 {return - arg;}
 
 
diff --git a/Couenne/src/expression/operators/CouenneExprPow.hpp b/Couenne/src/expression/operators/CouenneExprPow.hpp
index 5833f9c..d81116c 100644
--- a/Couenne/src/expression/operators/CouenneExprPow.hpp
+++ b/Couenne/src/expression/operators/CouenneExprPow.hpp
@@ -140,7 +140,7 @@ inline CouNumber safe_pow (CouNumber base,
 
   if (lbase < 0.) {
 
-    register int rndexp = COUENNE_round (lexponent);
+    int rndexp = COUENNE_round (lexponent);
 
     if (((fabs (lexponent - rndexp) < COUENNE_EPS) ||
 	 ((fabs (lexponent) > COUENNE_EPS) && 
@@ -155,7 +155,7 @@ inline CouNumber safe_pow (CouNumber base,
 
     if (lbase <= -COUENNE_INFINITY) {
 
-      register int intk = COUENNE_round (lexponent);
+      int intk = COUENNE_round (lexponent);
 
       if ((fabs (lexponent - intk) < COUENNE_EPS) && (intk % 2 || signpower))
 	retval = (lexponent < 0.) ? 0. : -COUENNE_INFINITY;
diff --git a/Couenne/src/expression/operators/CouenneExprSin.hpp b/Couenne/src/expression/operators/CouenneExprSin.hpp
index 1eecb2f..b96b50a 100644
--- a/Couenne/src/expression/operators/CouenneExprSin.hpp
+++ b/Couenne/src/expression/operators/CouenneExprSin.hpp
@@ -24,7 +24,7 @@ enum cou_trig {COU_SINE, COU_COSINE};
 
 
 /// normalize angle within [0,b] (typically, pi or 2pi)
-inline CouNumber modulo (register CouNumber a, register CouNumber b)
+inline CouNumber modulo (CouNumber a, CouNumber b)
   {return a - b * floor (a/b);}
 
 
diff --git a/Couenne/src/expression/operators/bounds/CouenneExprBCos.hpp b/Couenne/src/expression/operators/bounds/CouenneExprBCos.hpp
index 955ad27..6620f66 100644
--- a/Couenne/src/expression/operators/bounds/CouenneExprBCos.hpp
+++ b/Couenne/src/expression/operators/bounds/CouenneExprBCos.hpp
@@ -57,7 +57,7 @@ class exprLBCos: public exprOp {
 
 inline CouNumber exprLBCos::operator () () {
 
-  register CouNumber 
+  CouNumber 
     l = (*(arglist_ [0])) (),
     u = (*(arglist_ [1])) ();
 
@@ -110,7 +110,7 @@ class exprUBCos: public exprOp {
 
 inline CouNumber exprUBCos::operator () () {
 
-  register CouNumber 
+  CouNumber 
     l = (*(arglist_ [0])) (),
     u = (*(arglist_ [1])) ();
 
diff --git a/Couenne/src/expression/operators/bounds/CouenneExprBDiv.hpp b/Couenne/src/expression/operators/bounds/CouenneExprBDiv.hpp
index bbec888..d7084f1 100644
--- a/Couenne/src/expression/operators/bounds/CouenneExprBDiv.hpp
+++ b/Couenne/src/expression/operators/bounds/CouenneExprBDiv.hpp
@@ -16,7 +16,7 @@
 namespace Couenne {
 
 /// division that avoids NaN's and considers a sign when returning infinity
-static inline CouNumber safeDiv (register CouNumber a, register CouNumber b, int sign) {
+static inline CouNumber safeDiv (CouNumber a, CouNumber b, int sign) {
 
   if (fabs (a) < COUENNE_EPS) return 0;
   //    if (fabs (b) < COUENNE_EPS)) return 0;
@@ -63,10 +63,10 @@ class exprLBDiv: public exprOp {
 
 inline CouNumber exprLBDiv::operator () () {
 
-  register CouNumber n = (*(arglist_ [0])) ();
-  register CouNumber N = (*(arglist_ [1])) ();
-  register CouNumber d = (*(arglist_ [2])) ();
-  register CouNumber D = (*(arglist_ [3])) ();
+  CouNumber n = (*(arglist_ [0])) ();
+  CouNumber N = (*(arglist_ [1])) ();
+  CouNumber d = (*(arglist_ [2])) ();
+  CouNumber D = (*(arglist_ [3])) ();
                                                // (n,N,d,D)     lb 
   if (d > 0)                                   // (?,?,+,+)
     if   (n > 0)    return safeDiv (n,D,-1);      // (+,+,+,+) --> n/D
@@ -111,10 +111,10 @@ class exprUBDiv: public exprOp {
 
 inline CouNumber exprUBDiv::operator () () {
 
-  register CouNumber n = (*(arglist_ [0])) ();
-  register CouNumber N = (*(arglist_ [1])) ();
-  register CouNumber d = (*(arglist_ [2])) ();
-  register CouNumber D = (*(arglist_ [3])) ();
+  CouNumber n = (*(arglist_ [0])) ();
+  CouNumber N = (*(arglist_ [1])) ();
+  CouNumber d = (*(arglist_ [2])) ();
+  CouNumber D = (*(arglist_ [3])) ();
 
   if (d > 0)                                     // (n,N,d,D)     lb 
     if   (N < 0) return safeDiv (N,D,1);         // (-,-,+,+) --> N/D
diff --git a/Couenne/src/expression/operators/bounds/CouenneExprBMul.hpp b/Couenne/src/expression/operators/bounds/CouenneExprBMul.hpp
index a2c8c54..8930d45 100644
--- a/Couenne/src/expression/operators/bounds/CouenneExprBMul.hpp
+++ b/Couenne/src/expression/operators/bounds/CouenneExprBMul.hpp
@@ -22,7 +22,7 @@ namespace Couenne {
 #define MUL_INF  sqrt (COIN_DBL_MAX)
 
 /// product that avoids NaN's 
-inline CouNumber safeProd (register CouNumber a, register CouNumber b) {
+inline CouNumber safeProd (CouNumber a, CouNumber b) {
 
   if (a >  MUL_INF) return (b < -MUL_ZERO) ? -COIN_DBL_MAX : (b > MUL_ZERO) ?  COIN_DBL_MAX : 0.;
   if (a < -MUL_INF) return (b < -MUL_ZERO) ?  COIN_DBL_MAX : (b > MUL_ZERO) ? -COIN_DBL_MAX : 0.;
@@ -66,10 +66,10 @@ class exprLBMul: public exprOp {
 
 inline CouNumber exprLBMul::operator () () {
 
-  register CouNumber n = (*(arglist_ [0])) ();
-  register CouNumber N = (*(arglist_ [1])) ();
-  register CouNumber d = (*(arglist_ [2])) ();
-  register CouNumber D = (*(arglist_ [3])) ();
+  CouNumber n = (*(arglist_ [0])) ();
+  CouNumber N = (*(arglist_ [1])) ();
+  CouNumber d = (*(arglist_ [2])) ();
+  CouNumber D = (*(arglist_ [3])) ();
 
   if (d>=0)
     if   (n>=0) return safeProd (n,d);
@@ -121,10 +121,10 @@ inline CouNumber exprUBMul::operator () () {
 
   //  exprOp:: operator () ();
 
-  register CouNumber n = (*(arglist_ [0])) ();
-  register CouNumber N = (*(arglist_ [1])) ();
-  register CouNumber d = (*(arglist_ [2])) ();
-  register CouNumber D = (*(arglist_ [3])) ();
+  CouNumber n = (*(arglist_ [0])) ();
+  CouNumber N = (*(arglist_ [1])) ();
+  CouNumber d = (*(arglist_ [2])) ();
+  CouNumber D = (*(arglist_ [3])) ();
 
   if (d>0)
     if (N<0) return safeProd (N,d);
diff --git a/Couenne/src/expression/operators/bounds/CouenneExprBSin.hpp b/Couenne/src/expression/operators/bounds/CouenneExprBSin.hpp
index 3075e61..90fb066 100644
--- a/Couenne/src/expression/operators/bounds/CouenneExprBSin.hpp
+++ b/Couenne/src/expression/operators/bounds/CouenneExprBSin.hpp
@@ -57,7 +57,7 @@ class exprLBSin: public exprOp {
 
 inline CouNumber exprLBSin::operator () () {
 
-  register CouNumber 
+  CouNumber 
     l = (*(arglist_ [0])) (),
     u = (*(arglist_ [1])) ();
 
@@ -110,7 +110,7 @@ class exprUBSin: public exprOp {
 
 inline CouNumber exprUBSin::operator () () {
 
-  register CouNumber 
+  CouNumber 
     l = (*(arglist_ [0])) (),
     u = (*(arglist_ [1])) ();
 
diff --git a/Couenne/src/expression/operators/exprDiv.cpp b/Couenne/src/expression/operators/exprDiv.cpp
index e96a7a3..ff70440 100644
--- a/Couenne/src/expression/operators/exprDiv.cpp
+++ b/Couenne/src/expression/operators/exprDiv.cpp
@@ -220,7 +220,7 @@ bool exprDiv::isInteger () {
   arglist_ [1] -> getBounds (dl, du);
   arglist_ [0] -> getBounds (nl, nu);
 
-  //register CouNumber 
+  //CouNumber 
   //num = (*nl) (), 
   //den = (*dl) ();
 
diff --git a/Couenne/src/expression/operators/exprMul.cpp b/Couenne/src/expression/operators/exprMul.cpp
index d0ab6b7..659b2e8 100644
--- a/Couenne/src/expression/operators/exprMul.cpp
+++ b/Couenne/src/expression/operators/exprMul.cpp
@@ -38,7 +38,7 @@ exprMul::exprMul (expression *arg0, expression *arg1):
 
   if (compareExpr (arglist_, arglist_ + 1) > 0) {
 
-    register expression
+    expression
            *swap = arglist_ [0];
     arglist_ [0] = arglist_ [1];
     arglist_ [1] = swap;
@@ -100,7 +100,7 @@ expression *exprMul::simplify () {
     // TODO
   }
 
-  for (register int i=0; i<nargs_; i++) {
+  for (int i=0; i<nargs_; i++) {
 
     // check for null operands in multiplications
 
@@ -188,7 +188,7 @@ int exprMul::Linearity () {
   if (lin0 >= NONLINEAR) return NONLINEAR;
   if (lin0 == ZERO)      return ZERO;
 
-  for (register int i=1; i<nargs_; i++) {
+  for (int i=1; i<nargs_; i++) {
 
     int lin = arglist_ [i] -> Linearity ();
 
diff --git a/Couenne/src/expression/operators/exprSum.cpp b/Couenne/src/expression/operators/exprSum.cpp
index 2d3749b..d5dd9fe 100644
--- a/Couenne/src/expression/operators/exprSum.cpp
+++ b/Couenne/src/expression/operators/exprSum.cpp
@@ -64,7 +64,7 @@ expression *exprSum::simplify () {
   CouNumber total     = 0;
   bool      found_one = false;
 
-  for (register int i=0; i<nargs_; i++) {
+  for (int i=0; i<nargs_; i++) {
 
     // check for constant operands in multiplications
 
@@ -100,7 +100,7 @@ expression *exprSum:: differentiate (int index) {
 
   expression **arglist = new expression * [nargs_];
 
-  register int nonconst = 0;
+  int nonconst = 0;
 
   for (int i = 0; i < nargs_; i++) 
     if (arglist_ [i] -> dependsOn (index))
@@ -148,8 +148,8 @@ int exprSum::Linearity () {
 
   int linmax = arglist_ [0] -> Linearity ();
 
-  for (register int i=1; i<nargs_; i++) {
-    register int lin = arglist_ [i] -> Linearity ();
+  for (int i=1; i<nargs_; i++) {
+    int lin = arglist_ [i] -> Linearity ();
     if (lin > linmax) linmax = lin;
   }
   return linmax;
diff --git a/Couenne/src/heuristics/CouenneFPcreateMILP.cpp b/Couenne/src/heuristics/CouenneFPcreateMILP.cpp
index f0bd9f4..baf805d 100644
--- a/Couenne/src/heuristics/CouenneFPcreateMILP.cpp
+++ b/Couenne/src/heuristics/CouenneFPcreateMILP.cpp
@@ -386,7 +386,7 @@ int PSDize (int n, double *A, double *B, bool doSqrRoot) {
 
   for (int j=0; j<n; ++j) {
 
-    register double multEig = doSqrRoot ? sqrt (eigenval [j]) : 
+    double multEig = doSqrRoot ? sqrt (eigenval [j]) : 
                                                 eigenval [j];
 
     for (int i=0; i<n; ++i)
diff --git a/Couenne/src/heuristics/CouenneFPpool.cpp b/Couenne/src/heuristics/CouenneFPpool.cpp
index 1b90f92..d0cd5cb 100644
--- a/Couenne/src/heuristics/CouenneFPpool.cpp
+++ b/Couenne/src/heuristics/CouenneFPpool.cpp
@@ -216,11 +216,11 @@ bool compareSol::operator() (const CouenneFPsolution &one,
 
   return one. compare (two, comparedTerm_);
 
-  // register const double
+  // const double
   //   *x1 = one.x (),
   //   *x2 = two.x ();
 
-  // register int n = one.n ();
+  // int n = one.n ();
 
   // while (n--)
   //   if ((*x1++ - *x2++) <= COMP_TOLERANCE)
@@ -243,15 +243,15 @@ void CouenneFPpool::findClosestAndReplace (double *&sol, const double *nSol, int
       {
 	//compute distance of pool solution and NLP solution
 
-	register double 
+	double 
 	   dist = 0.0,
 	   delta;
 
-	const register double 
+	const double 
 	  *x = i -> x (),
 	  *s = nSol;
 
-	register bool move_on = false;
+	bool move_on = false;
 
 	for (int j = nvars, k=0; j--; ++k) {
 
diff --git a/Couenne/src/interfaces/CouenneMINLPInterface.cpp b/Couenne/src/interfaces/CouenneMINLPInterface.cpp
index ccf32e9..d37d37d 100644
--- a/Couenne/src/interfaces/CouenneMINLPInterface.cpp
+++ b/Couenne/src/interfaces/CouenneMINLPInterface.cpp
@@ -229,7 +229,7 @@ void
 CouenneMINLPInterface::registerOptions
 (SmartPtr<RegisteredOptions> roptions)
 {
-  // We try to register the options - if those have been registered
+  // We try to the options - if those have been registered
   // already, we catch the exception and don't need to do it again
   try {
     register_general_options(roptions);
diff --git a/Couenne/src/interfaces/CouenneTNLP.cpp b/Couenne/src/interfaces/CouenneTNLP.cpp
index c9bea29..834acab 100644
--- a/Couenne/src/interfaces/CouenneTNLP.cpp
+++ b/Couenne/src/interfaces/CouenneTNLP.cpp
@@ -469,9 +469,9 @@ bool CouenneTNLP::eval_jac_g (Index n, const Number* x, bool new_x,
     // fill in Jacobian's values. Evaluate each member using the
     // domain modified above by the new value of x
 
-    register expression **e = Jac_. expr ();
+    expression **e = Jac_. expr ();
 
-    for (register int i=nele_jac; i--;)
+    for (int i=nele_jac; i--;)
       *values++ = (**(e++)) ();
   }
 
diff --git a/Couenne/src/main/BonCouenneSetup.hpp b/Couenne/src/main/BonCouenneSetup.hpp
index 022b278..3bd549e 100644
--- a/Couenne/src/main/BonCouenneSetup.hpp
+++ b/Couenne/src/main/BonCouenneSetup.hpp
@@ -72,7 +72,7 @@ namespace Couenne {
 			   CouenneInterface *ci = NULL,
 			   Bonmin::Bab *bb = NULL);
     
-    /** register the options */
+    /** the options */
     virtual void registerOptions();
     /** Register all Couenne options.*/
     static void registerAllOptions(Ipopt::SmartPtr<Bonmin::RegisteredOptions> roptions);
diff --git a/Couenne/src/main/Couenne.cpp b/Couenne/src/main/Couenne.cpp
index 7a5ab67..e96ead2 100644
--- a/Couenne/src/main/Couenne.cpp
+++ b/Couenne/src/main/Couenne.cpp
@@ -88,7 +88,7 @@ int main (int argc, char *argv[]) {
 
   double time_start = CoinCpuTime();
   
-  // register options to prepare for parsing the command line
+  // options to prepare for parsing the command line
   SmartPtr<Bonmin::RegisteredOptions> roptions = new Bonmin::RegisteredOptions();
   Couenne::CouenneSetup::registerAllOptions(roptions);
 #ifdef COIN_HAS_ASL
diff --git a/Couenne/src/main/CouenneBab.cpp b/Couenne/src/main/CouenneBab.cpp
index 7093e06..94f0cec 100644
--- a/Couenne/src/main/CouenneBab.cpp
+++ b/Couenne/src/main/CouenneBab.cpp
@@ -525,7 +525,7 @@ void CouenneBab::branchAndBound (Bonmin::BabSetupBase & s) {
 
 #ifdef SIGNAL
     CoinSighandler_t saveSignal = SIG_DFL;
-    // register signal handler
+    // signal handler
     saveSignal = signal (SIGINT,couenne_signal_handler);
     currentBranchModel = &model_;
 #endif
diff --git a/Couenne/src/main/CouenneOSInterface.cpp b/Couenne/src/main/CouenneOSInterface.cpp
index 0f97a81..b233647 100644
--- a/Couenne/src/main/CouenneOSInterface.cpp
+++ b/Couenne/src/main/CouenneOSInterface.cpp
@@ -102,7 +102,7 @@ CouenneProblem* CouenneOSInterface::getCouenneProblem() {
 
   // fill in lower and upper bounds ///////////////////////////////////////////////////////////////
 
-  for (register int i=n_var; i--;) {
+  for (int i=n_var; i--;) {
     problem -> Lb (i) = - COUENNE_INFINITY;
     problem -> Ub (i) =   COUENNE_INFINITY;
     problem -> X  (i) = 0;
diff --git a/Couenne/src/main/CouenneSolver.cpp b/Couenne/src/main/CouenneSolver.cpp
index 88715af..a17176b 100644
--- a/Couenne/src/main/CouenneSolver.cpp
+++ b/Couenne/src/main/CouenneSolver.cpp
@@ -63,7 +63,7 @@ int main (int argc, char *argv[]) {
 
   double time_start = CoinCpuTime();
   
-	// register options to prepare for parsing the command line
+	// options to prepare for parsing the command line
 	SmartPtr<Bonmin::RegisteredOptions> roptions = new Bonmin::RegisteredOptions();
 	Bonmin::CouenneSetup::registerAllOptions(roptions);
 #ifdef COIN_HAS_ASL
diff --git a/Couenne/src/problem/CouenneProblem.hpp b/Couenne/src/problem/CouenneProblem.hpp
index e5b54a5..2d26e59 100644
--- a/Couenne/src/problem/CouenneProblem.hpp
+++ b/Couenne/src/problem/CouenneProblem.hpp
@@ -60,7 +60,7 @@ class Nauty;
     int sign;
   public:
     void node(int, double, double, double, int, int);
-    inline void color_vertex (register int k) {color = k;}
+    inline void color_vertex (int k) {color = k;}
     inline int get_index () const {return index;}
     inline double get_coeff () const {return coeff;}
     inline double get_lb () const {return lb;}
@@ -68,13 +68,13 @@ class Nauty;
     inline int get_color () const {return color;}
     inline int get_code () const {return code;}
     inline int get_sign () const {return sign;}
-    inline void bounds(register double a, register double b){ lb = a; ub = b;}
+    inline void bounds(double a, double b){ lb = a; ub = b;}
   };
 
 #define COUENNE_EPS_SYMM 1e-8
 
   struct myclass0 {
-    inline bool operator() (register const Node &a, register const Node &b) {
+    inline bool operator() (const Node &a, const Node &b) {
 
       return ((               a.get_code  () <  b.get_code  ())                     ||
 	      ((              a.get_code  () == b.get_code  ()                      &&
@@ -120,13 +120,13 @@ class Nauty;
     
       
   struct myclass {
-    inline bool operator() (register const  Node &a, register const Node &b) {
+    inline bool operator() (const  Node &a, const Node &b) {
       return (a.get_index() < b.get_index() );
     }
   };
 
 struct less_than_str {
-  inline bool operator() (register const  char *a, register const char *b) const
+  inline bool operator() (const  char *a, const char *b) const
   {return strcmp (a, b) < 0;}
 };
 
@@ -394,7 +394,7 @@ class CouenneProblem {
   void Compute_Symmetry() const;
   void Print_Orbits() const;
   void ChangeBounds (const double * , const double *, int ) const;
-  inline bool compare (register Node &a, register Node &b) const;
+  inline bool compare (Node &a, Node &b) const;
   Nauty *getNtyInfo () {return nauty_info;}
 
   // bool node_sort (  Node  a, Node  b);
diff --git a/Couenne/src/problem/CouenneSymmetry.cpp b/Couenne/src/problem/CouenneSymmetry.cpp
index a2773f6..4354a45 100644
--- a/Couenne/src/problem/CouenneSymmetry.cpp
+++ b/Couenne/src/problem/CouenneSymmetry.cpp
@@ -38,7 +38,7 @@ void Node::node(int i, double c , double l, double u, int cod, int s){
   sign = s;
 }
 
-inline bool CouenneProblem::compare (register Node &a, register Node &b) const {
+inline bool CouenneProblem::compare (Node &a, Node &b) const {
   if(a.get_code() == b.get_code() )
     if(a.get_coeff() == b.get_coeff() )
       if(a.get_sign() == b.get_sign() )
diff --git a/Couenne/src/problem/checkNLP.cpp b/Couenne/src/problem/checkNLP.cpp
index ec4d50d..c7b52ee 100644
--- a/Couenne/src/problem/checkNLP.cpp
+++ b/Couenne/src/problem/checkNLP.cpp
@@ -33,7 +33,7 @@ bool CouenneProblem::checkNLP (const double *solution, double &obj, bool recompu
 
   // pre-check on original variables --- this is done after every LP,
   // and should be efficient
-  for (register int i=0; i < nOrigVars_ - ndefined_; i++) {
+  for (int i=0; i < nOrigVars_ - ndefined_; i++) {
 
     if (variables_ [i] -> Multiplicity () <= 0) 
       continue;
@@ -588,7 +588,7 @@ bool CouenneProblem::checkNLP2(const double *solution,
 
     const bool *initIsInt = getRecordBestSol()->getInitIsInt();
     printf("Integrality:\n");
-    for (register int i=0; i<nVars(); i++) {
+    for (int i=0; i<nVars(); i++) {
 
       if (variables_ [i] -> Multiplicity () <= 0) 
 	continue;
@@ -600,7 +600,7 @@ bool CouenneProblem::checkNLP2(const double *solution,
     printf("\n");
 
     printf("VAR:\n");
-    for (register int i=0; i<nVars(); i++) {
+    for (int i=0; i<nVars(); i++) {
 
       if (variables_ [i] -> Multiplicity () <= 0) 
 	continue;
@@ -612,7 +612,7 @@ bool CouenneProblem::checkNLP2(const double *solution,
     printf("\n");
 
     printf("AUX:\n");
-    for (register int i=0; i<nVars(); i++) {
+    for (int i=0; i<nVars(); i++) {
 
       if (variables_ [i] -> Multiplicity () <= 0) 
 	continue;
@@ -624,7 +624,7 @@ bool CouenneProblem::checkNLP2(const double *solution,
     printf("\n");
 
     printf("mult 0:\n");
-    for (register int i=0; i<nVars(); i++) {
+    for (int i=0; i<nVars(); i++) {
 
       if (variables_ [i] -> Multiplicity () <= 0) { 
 	printf(" %d", i);
diff --git a/Couenne/src/readnl/CouenneAmplInterface.cpp b/Couenne/src/readnl/CouenneAmplInterface.cpp
index 00e1548..29619f5 100644
--- a/Couenne/src/readnl/CouenneAmplInterface.cpp
+++ b/Couenne/src/readnl/CouenneAmplInterface.cpp
@@ -450,7 +450,7 @@ bool CouenneAmplInterface::readnl() {
 
   // count all linear terms
   if (A_colstarts && A_vals)         // Constraints' linear info is stored in A_vals
-    for (register int j = A_colstarts [n_var]; j--;) {
+    for (int j = A_colstarts [n_var]; j--;) {
 
       real coeff = A_vals [j];
 
@@ -458,7 +458,7 @@ bool CouenneAmplInterface::readnl() {
 	nterms [A_rownos [j]] ++;
     }
   else {                             // Constraints' linear info is stored in Cgrad
-    for (register int i = 0; i < n_con; i++)
+    for (int i = 0; i < n_con; i++)
       for (congrad = Cgrad [i]; 
 	   congrad; 
 	   congrad = congrad -> next) 
@@ -471,7 +471,7 @@ bool CouenneAmplInterface::readnl() {
   CouNumber **coeff  = new CouNumber * [n_con];
   int       **indexL = new int       * [n_con];
 
-  for (register int i = n_con; i--;) 
+  for (int i = n_con; i--;) 
     *indexL++ = NULL;
 
   indexL -= n_con;
@@ -481,7 +481,7 @@ bool CouenneAmplInterface::readnl() {
 
   if (A_colstarts && A_vals)         // Constraints' linear info is stored in A_vals
     for (int j = 0; j < n_var; j++)
-      for (register int i = A_colstarts [j], k = A_colstarts [j+1] - i; k--; i++) {
+      for (int i = A_colstarts [j], k = A_colstarts [j+1] - i; k--; i++) {
 
 	int rowno = A_rownos [i],
 	    nt    = nterms [rowno] --;
@@ -635,28 +635,28 @@ bool CouenneAmplInterface::readnl() {
     real *Uvx_copy = Uvx;
 
     if (!Uvx_copy)
-      for (register int i=0; i<n_var; i++) {
+      for (int i=0; i<n_var; i++) {
 
-	register int j = 2*i;
+	int j = 2*i;
 
         problem -> Lb (i) = LUv[j]   <= -COUENNE_INFINITY ? -COUENNE_INFINITY : LUv[j]  ;
         problem -> Ub (i) = LUv[j+1] >=  COUENNE_INFINITY ?  COUENNE_INFINITY : LUv[j+1];
       }
     else
-      for (register int i=n_var; i--;) {
+      for (int i=n_var; i--;) {
 	problem -> Lb (i) = LUv [i]      <= -COUENNE_INFINITY ? -COUENNE_INFINITY : LUv[i];
 	problem -> Ub (i) = Uvx_copy [i] >=  COUENNE_INFINITY ?  COUENNE_INFINITY : Uvx_copy[i];
       }
 
   } else
-    for (register int i=n_var; i--;) {
+    for (int i=n_var; i--;) {
     	problem -> Lb (i) = - COUENNE_INFINITY;
     	problem -> Ub (i) =   COUENNE_INFINITY;
     }
 
   // initial x ////////////////////////////////////////////////////////////////////
 
-  for (register int i=n_var; i--;) 
+  for (int i=n_var; i--;) 
 
     if (X0 && havex0 [i]) problem -> X (i) = X0 [i]; 
 
@@ -673,7 +673,7 @@ bool CouenneAmplInterface::readnl() {
       problem -> X (i) = x;
     }
 
-  for (register int i=n_var; i < problem -> nDefVars() ; i++) {  //FIXME: shouldn't this loop go until n_var + problem -> nDefVars() ?
+  for (int i=n_var; i < problem -> nDefVars() ; i++) {  //FIXME: shouldn't this loop go until n_var + problem -> nDefVars() ?
 
   	problem -> X  (i) =  0.;
   	problem -> Lb (i) = -COUENNE_INFINITY;
diff --git a/Couenne/src/readnl/readnl.cpp b/Couenne/src/readnl/readnl.cpp
index b6a2e55..c6b59bc 100644
--- a/Couenne/src/readnl/readnl.cpp
+++ b/Couenne/src/readnl/readnl.cpp 
@@ -235,7 +236,7 @@ int CouenneProblem::readnl (const ASL *asl) {
 
   // count all linear terms
   if (A_colstarts && A_vals)         // Constraints' linear info is stored in A_vals
-    for (register int j = A_colstarts [n_var]; j--;) {
+    for (int j = A_colstarts [n_var]; j--;) {
 
       real coeff = A_vals [j];
 
@@ -243,7 +244,7 @@ int CouenneProblem::readnl (const ASL *asl) {
 	nterms [A_rownos [j]] ++;
     }
   else {                             // Constraints' linear info is stored in Cgrad
-    for (register int i = 0; i < n_con; i++)
+    for (int i = 0; i < n_con; i++)
       for (congrad = Cgrad [i]; 
 	   congrad; 
 	   congrad = congrad -> next) 
@@ -256,7 +257,7 @@ int CouenneProblem::readnl (const ASL *asl) {
   CouNumber **coeff  = new CouNumber * [n_con];
   int       **indexL = new int       * [n_con];
 
-  for (register int i = n_con; i--;) 
+  for (int i = n_con; i--;) 
     *indexL++ = NULL;
 
   indexL -= n_con;
@@ -266,7 +267,7 @@ int CouenneProblem::readnl (const ASL *asl) {
 
   if (A_colstarts && A_vals)         // Constraints' linear info is stored in A_vals
     for (int j = 0; j < n_var; j++)
-      for (register int i = A_colstarts [j], k = A_colstarts [j+1] - i; k--; i++) {
+      for (int i = A_colstarts [j], k = A_colstarts [j+1] - i; k--; i++) {
 
 	int rowno = A_rownos [i],
 	    nt    = nterms [rowno] --;
@@ -428,28 +429,28 @@ int CouenneProblem::readnl (const ASL *asl) {
     real *Uvx_copy = Uvx;
 
     if (!Uvx_copy)
-      for (register int i=0; i<n_var; i++) {
+      for (int i=0; i<n_var; i++) {
 
-	register int j = 2*i;
+	int j = 2*i;
 
 	Lb (i) = LUv [j];
 	Ub (i) = LUv [j+1];
       }
     else
-      for (register int i=n_var; i--;) {
+      for (int i=n_var; i--;) {
 	Lb (i) = LUv [i];
 	Ub (i) = Uvx_copy [i];
       }
 
   } else
-    for (register int i=n_var; i--;) {
+    for (int i=n_var; i--;) {
       Lb (i) = - COUENNE_INFINITY;
       Ub (i) =   COUENNE_INFINITY;
     }
 
   // initial x ////////////////////////////////////////////////////////////////////
 
-  for (register int i=n_var; i--;) 
+  for (int i=n_var; i--;) 
 
     if (X0 && havex0 [i]) X (i) = X0 [i];
 
@@ -466,7 +467,7 @@ int CouenneProblem::readnl (const ASL *asl) {
       X (i) = x;
     }
 
-  for (register int i=n_var; i<ndefined_; i++) {
+  for (int i=n_var; i<ndefined_; i++) {
 
     X  (i) =  0.;
     Lb (i) = -COUENNE_INFINITY;
diff --git a/Couenne/src/standardize/splitAux.cpp b/Couenne/src/standardize/splitAux.cpp
index 73be99d..886dc37 100644
--- a/Couenne/src/standardize/splitAux.cpp
+++ b/Couenne/src/standardize/splitAux.cpp
@@ -271,7 +271,7 @@ int CouenneProblem::splitAux (CouNumber rhs, expression *body, expression *&rest
       linind2 = new int       [nlin + 1];
       lincoe2 = new CouNumber [nlin + 1];
 
-      register int j;
+      int j;
 
       //if (jnlst_ -> ProduceOutput (Ipopt::J_ALL, J_REFORMULATE)) {
       //for (j=0; j<mid;  j++) printf ("{%g x%d} ", lincoe [j], linind [j]);
diff --git a/Couenne/src/util/rootQ.cpp b/Couenne/src/util/rootQ.cpp
index 144ce5f..5f5806e 100644
--- a/Couenne/src/util/rootQ.cpp
+++ b/Couenne/src/util/rootQ.cpp
@@ -18,13 +18,13 @@ namespace Couenne {
 
 /* compute Q(x) */
 
-CouNumber Q (register int k, CouNumber x) {
+CouNumber Q (int k, CouNumber x) {
 
-  register CouNumber xp = x, Q = 1.;
+  CouNumber xp = x, Q = 1.;
 
   k *= 2;
 
-  for (register int i=2; i<=k; i++) {
+  for (int i=2; i<=k; i++) {
 
     Q += (CouNumber) i * xp;
     xp *= x;
@@ -44,7 +44,7 @@ CouNumber rootQ (int k) {
   if (k==1) return - 0.5; // for x^3, solution is -1/2
   else {
 
-    register CouNumber 
+    CouNumber 
       l  = - 1.0 + 0.5 / k, 
       u  = - 0.5,
       /* Ql = Q (k, l), Qu = Q (k, u), */
@@ -71,7 +71,7 @@ CouNumber rootQ (int k) {
 #ifdef DEBUG_ROOTQ
 int main () {
 
-  register int k;
+  int k;
   CouNumber x, q;
 
   for (k=6; --k;) {
