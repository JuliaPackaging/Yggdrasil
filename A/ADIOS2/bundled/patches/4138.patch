From 11893a6355f2099a30d5a8c64ea810291fbee99e Mon Sep 17 00:00:00 2001
From: dill Upstream <robot@adios2>
Date: Thu, 4 Apr 2024 14:06:45 -0400
Subject: [PATCH 1/5] dill 2024-04-04 (55420dee)

Code extracted from:

    https://github.com/GTkorvo/dill.git

at commit 55420dee12c25ae892e446cfa6e615bef04b14da (master).

Upstream Shortlog
-----------------
---
 .clang-format  | 18 ++++++++++++++++++
 CMakeLists.txt | 19 ++++++++++++++-----
 arm8.c         |  2 ++
 base.ops       | 11 +++++++++--
 4 files changed, 43 insertions(+), 7 deletions(-)
 create mode 100644 .clang-format

diff --git a/.clang-format b/.clang-format
new file mode 100644
index 0000000000..ebaa492bc6
--- /dev/null
+++ b/.clang-format
@@ -0,0 +1,18 @@
+Language:  Cpp
+BasedOnStyle:  Chromium
+BreakBeforeBraces:  Custom
+IndentWidth: 4
+ContinuationIndentWidth: 4
+AccessModifierOffset: -4
+Standard: Cpp11
+ColumnLimit: 80
+AllowAllParametersOfDeclarationOnNextLine: false
+AlwaysBreakAfterReturnType: All
+AlignEscapedNewlines: Right
+AlignAfterOpenBracket: Align
+SortUsingDeclarations: false
+IndentCaseLabels: false
+BraceWrapping:
+  AfterFunction: true
+  SplitEmptyFunction: true
+  SplitEmptyRecord: true
diff --git a/CMakeLists.txt b/CMakeLists.txt
index b90f757087..b5bf2a3394 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -102,7 +102,7 @@ check_type_size("void*" CMAKE_SIZEOF_VOID_P)
 check_type_size("long" SIZEOF_LONG)
 set(NATIVE_CG TRUE)
 unset(NATIVE_ARCH)
-if(CMAKE_SYSTEM_PROCESSOR MATCHES "i.86|x86_64|AMD64")
+if(CMAKE_SYSTEM_PROCESSOR MATCHES "i.86|x86_64|AMD64|amd64")
   if(CMAKE_SIZEOF_VOID_P EQUAL 8)
     set(NATIVE_ARCH x86_64)
     set(HOST_X86_64 1)
@@ -117,6 +117,9 @@ if(CMAKE_SYSTEM_PROCESSOR MATCHES "i.86|x86_64|AMD64")
   if(NOT (CMAKE_SIZEOF_VOID_P EQUAL SIZEOF_LONG))
     set(BASE_OPS_ARG "-msvc_long")
   endif()
+  if(BUILD_SHARED_LIBS)
+    set(BASE_OPS_ARG "${BASE_OPS_ARG} -build_shared")
+  endif()
 elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "arm.5.*")
   set(NATIVE_ARCH arm5)
   set(HOST_ARM5 1)
@@ -183,16 +186,21 @@ set(ARM_HARD_FLOAT ${HARDFP_AVAILABLE})
 
 option(DILL_IGNORE_NATIVE  "Build to do emulation, regardless of architecture"
   OFF)
+option(DILL_NATIVE_ONLY  "Build to native code only"  ON)
 if(DILL_IGNORE_NATIVE)
   set(NATIVE_CG FALSE)
   set(NATIVE_ARCH UNSUPPORTED)
 endif()
 set(LIBFFI_INTERNAL OFF)
-find_package(LibFFI)
+if (DILL_NATIVE_ONLY)
+  set(LIBFFI_FOUND FALSE)
+else()
+  find_package(LibFFI)
+endif()
 if(LIBFFI_FOUND)
   message(STATUS "Enabling emulation")
   set(EMULATION_POSSIBLE TRUE)
-elseif(DILL_IGNORE_NATIVE OR (NATIVE_ARCH STREQUAL "UNSUPPORTED"))
+elseif((DILL_IGNORE_NATIVE OR (NATIVE_ARCH STREQUAL "UNSUPPORTED")) AND NOT DILL_NATIVE_ONLY)
   find_program (AUTOCONF autoconf)
   find_program (AUTOMAKE automake)
   if ((AUTOCONF STREQUAL "AUTOCONF-NOTFOUND") OR (AUTOMAKE STREQUAL "AUTOMAKE-NOTFOUND"))
@@ -334,7 +342,6 @@ check_include_files(memory.h HAVE_MEMORY_H)
 check_include_files(sys/mman.h HAVE_SYS_MMAN_H)
 include(CheckSymbolExists)
 check_symbol_exists(__clear_cache "" CLEAR_CACHE_DEFINED)
-message(STATUS "Clear cache defined is ${CLEAR_CACHE_DEFINED}")
 
 set(NO_DISASSEMBLER TRUE)
 if(DILL_ENABLE_DISASSEMBLY)
@@ -526,8 +533,10 @@ if(NOT DILL_QUIET)
   message(STATUS "CMAKE_BUILD_TYPE = ${CMAKE_BUILD_TYPE}" )
   message(STATUS "DILL_ENABLE_DISASSEMBLY = ${DILL_ENABLE_DISASSEMBLY}" )
   message(STATUS "DILL_MULTI_TARGET = ${DILL_MULTI_TARGET}" )
-  message(STATUS "BUILD_SHARED_LIBS = ${BUILD_SHARED_LIBS}" )
+  message(STATUS "DILL_IGNORE_NATIVE = ${DILL_IGNORE_NATIVE}" )
+  message(STATUS "DILL_NATIVE_ONLY = ${DILL_NATIVE_ONLY}" )
   message(STATUS "BUILD_TESTING = ${BUILD_TESTING}" )
+  message(STATUS "BUILD_SHARED_LIBS = ${BUILD_SHARED_LIBS}" )
   message(STATUS "Change a value with: cmake -D<Variable>=<Value>" )
   message(STATUS "-----------------------------------------------------------------------------")
 endif()
diff --git a/arm8.c b/arm8.c
index d189463581..372899d8a9 100644
--- a/arm8.c
+++ b/arm8.c
@@ -1517,6 +1517,8 @@ arm8_PLT_emit(dill_stream s, int package)
     }
 }
 
+extern void arm8_rt_call_link(char *code, call_t *t);
+
 static void
 arm8_call_link(dill_stream s)
 {
diff --git a/base.ops b/base.ops
index cd7e3bf3c0..003b5b5138 100755
--- a/base.ops
+++ b/base.ops
@@ -6,9 +6,12 @@ $MSVC_LONG = 0;
 while ($_ = $ARGV[0]) {
 	shift;
 	last if /^--$/;
-	if (/^-msvc_long/) {$MSVC_LONG = 1;}
+	if (/-msvc_long/) {$MSVC_LONG = 1;}
+	if (/-build_shared/) {$BUILD_SHARED = 1;}
 }
 
+print "BUILD_SHARED is $BUILD_SHARED\n";
+
 sub upperc {
     local($_) = pop(@_);
     tr/[a-z]/[A-Z]/;
@@ -65,7 +68,11 @@ print HOUT "#define dill_jalp(s, return_addr_reg, target) (s->j->jal)(s, return_
 
 print HOUT "#define dill_special(s, type, param) if (s->j->special) (s->j->special)(s, type, param)\n";
 print HOUT "#if defined(_MSC_VER) && !defined(DILL_SRC)\n";
-print HOUT "#define DILL_DECLSPEC    __declspec(dllimport)\n";
+if ($BUILD_SHARED) {
+    print HOUT "#define DILL_DECLSPEC    __declspec(dllimport)\n";
+} else {
+    print HOUT "#define DILL_DECLSPEC\n";
+}
 print HOUT "#else\n";
 print HOUT "#define DILL_DECLSPEC\n";
 print HOUT "#endif\n";

From 404e777e74b9f5025abf0d35ef1584bfb47d3cbe Mon Sep 17 00:00:00 2001
From: ffs Upstream <robot@adios2>
Date: Mon, 15 Apr 2024 10:48:22 -0400
Subject: [PATCH 2/5] ffs 2024-04-15 (3eebea4d)

Code extracted from:

    https://github.com/GTkorvo/ffs.git

at commit 3eebea4d6ff7d2c0033d823a257b11e7d7caa4f9 (master).

Upstream Shortlog
-----------------
---
 .github/workflows/build-and-test.yml          |   3 +
 CMakeLists.txt                                |   5 +
 cmake/BisonFlexSub.cmake                      |   3 +-
 cod/cg.c                                      |   4 +
 cod/cod.h                                     |  50 +-
 cod/cod.y                                     |   4 +-
 cod/pregen_source/Windows/cod.l               |  63 ---
 cod/pregen_source/Windows/cod.tab.c           | 518 +++++++-----------
 cod/pregen_source/Windows/cod.tab.h           | 320 +++++------
 cod/pregen_source/Windows/cod.y               |   6 +-
 cod/pregen_source/Windows/lex.yy.c            |  63 ---
 cod/standard.c                                |   6 +-
 cod/tests/CMakeLists.txt                      |   5 +-
 cod/tests/general.ops                         |   1 +
 cod/tests/t1.c                                |   2 +-
 ffs/ffs.c                                     |   3 +-
 ffs/ffs.h.in                                  |  94 ++--
 ffs/tests/context_test.c                      |   3 +
 fm/fm.h                                       | 148 +++--
 fm/fm_dump.c                                  |   2 +-
 fm/fm_formats.c                               |  20 +-
 fm/io_interface.h                             |   2 +-
 fm/nt_io.c                                    |  13 +-
 fm/tests/scale_test.c                         |   2 +-
 scripts/ci/cmake/windows-common.cmake         |   5 +
 .../windows2022-vs2022-msvc-static.cmake      |   8 +
 26 files changed, 529 insertions(+), 824 deletions(-)
 create mode 100644 scripts/ci/cmake/windows2022-vs2022-msvc-static.cmake

diff --git a/.github/workflows/build-and-test.yml b/.github/workflows/build-and-test.yml
index 0b9926ae9e..6614bcfe79 100644
--- a/.github/workflows/build-and-test.yml
+++ b/.github/workflows/build-and-test.yml
@@ -88,12 +88,15 @@ jobs:
         jobname: [
           windows2019-vs2019-clang,
           windows2022-vs2022-msvc,
+          windows2022-vs2022-msvc-static,
           macos-clang ]
         include:
         - jobname: windows2019-vs2019-clang
           vm: windows-2019
         - jobname: windows2022-vs2022-msvc
           vm: windows-2022
+        - jobname: windows2022-vs2022-msvc-static
+          vm: windows-2022
         - jobname: macos-clang
           vm: macos-latest
 
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7d8589f95e..3cd2733e9d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -186,6 +186,10 @@ add_custom_command(
 
 add_custom_target(docs ALL DEPENDS "cod_node.c")
 
+if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
+   SET_SOURCE_FILES_PROPERTIES(cod.tab.c PROPERTIES COMPILE_FLAGS -Wno-unused-function)
+endif()
+
 add_custom_target(generated DEPENDS cod_node.c ${BISON_CODParser_OUTPUT_SOURCE})
 
 list(APPEND COD_MASTER_SRC_LIST
@@ -254,6 +258,7 @@ endif()
 CHECK_INCLUDE_FILE(malloc.h HAVE_MALLOC_H)
 CHECK_INCLUDE_FILE(memory.h HAVE_MEMORY_H)
 CHECK_INCLUDE_FILE(netdb.h HAVE_NETDB_H)
+CHECK_INCLUDE_FILE(netinet/in.h HAVE_NETINET_IN_H)
 CHECK_INCLUDE_FILE(sockLib.h HAVE_SOCKLIB_H)
 CHECK_INCLUDE_FILE(stdarg.h STDC_HEADERS)
 CHECK_INCLUDE_FILE(stdlib.h HAVE_STDLIB_H)
diff --git a/cmake/BisonFlexSub.cmake b/cmake/BisonFlexSub.cmake
index 40e2e275f5..dedcd711c6 100644
--- a/cmake/BisonFlexSub.cmake
+++ b/cmake/BisonFlexSub.cmake
@@ -1,7 +1,8 @@
 FUNCTION (SETUP_BISON_FLEX_SUB)
 
 IF ((${CMAKE_SYSTEM_NAME} STREQUAL "Darwin") OR
-   (${CMAKE_SYSTEM_NAME} STREQUAL "Linux"))
+   (${CMAKE_SYSTEM_NAME} STREQUAL "Linux") OR
+   (${CMAKE_SYSTEM_NAME} STREQUAL "FreeBSD"))
    set (BISON_FLEX_PRECOMPILE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/cod/pregen_source/Linux")
 elseif (${CMAKE_SYSTEM_NAME} STREQUAL "Windows")
    set (BISON_FLEX_PRECOMPILE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/cod/pregen_source/Windows")
diff --git a/cod/cg.c b/cod/cg.c
index 1b41d8d3af..e4642c9edc 100644
--- a/cod/cg.c
+++ b/cod/cg.c
@@ -148,6 +148,7 @@ cg_required_align(dill_stream s, sm_ref node)
     required_align = dill_type_align(s, DILL_P);
     break;
   default:
+   required_align = 0; //silence warning
     assert(0);
   }
   return required_align;
@@ -1750,6 +1751,7 @@ execute_operator_cg(dill_stream s, operator_t op, int op_type, dill_reg result,
 		} else if (typ->node_type == cod_array_type_decl) {
 		    size = typ->node.array_type_decl.cg_element_size;
 		} else {
+		    size = 1; // avoid warning
 		    assert(0);
 		}
 	    } else if ((ptr->node_type == cod_operator) && (ptr->node.operator.op == op_address)) {
@@ -1758,6 +1760,7 @@ execute_operator_cg(dill_stream s, operator_t op, int op_type, dill_reg result,
 		if (cod_expr_is_string(ptr)) {
 		    size = 1;
 		} else {
+		    size = 1;  // silence warning
 		    assert(FALSE);
 		}
 	    }
@@ -1898,6 +1901,7 @@ execute_operator_cg(dill_stream s, operator_t op, int op_type, dill_reg result,
 		    if (cod_expr_is_string(ptr)) {
 			size = 1;
 		    } else {
+			size = 1; // avoid warning
 			assert(FALSE);
 		    }
 		}
diff --git a/cod/cod.h b/cod/cod.h
index 0a866ea8e8..41a611aceb 100644
--- a/cod/cod.h
+++ b/cod/cod.h
@@ -6,14 +6,6 @@
 extern "C" {
 #endif
 
-#ifndef FFS_DECL_SPEC
-#if defined(_MSC_VER) && !defined(FFS_SRC)
-#define FFS_DECLSPEC    __declspec(dllimport)
-#else
-#define FFS_DECLSPEC
-#endif
-#endif
-
 #include <stdint.h>
 
 /*!
@@ -112,7 +104,7 @@ typedef cod_extern_entry *cod_extern_list;
  * \return Will return a new initialized cod_parse_context unless there is
  * no available memory.
  */
-extern FFS_DECLSPEC cod_parse_context new_cod_parse_context(void);
+extern cod_parse_context new_cod_parse_context(void);
 
 /*!
  * Free a handle to an cod_parse_context.
@@ -121,7 +113,7 @@ extern FFS_DECLSPEC cod_parse_context new_cod_parse_context(void);
  * Calling this routine frees all memory associated with the parse context,
  * but not that of code that has been generated from this context.
  */
-extern FFS_DECLSPEC void cod_free_parse_context(cod_parse_context context);
+extern void cod_free_parse_context(cod_parse_context context);
 
 /*!
  * Associate a set of "name, external address" pairs with a parse context 
@@ -135,7 +127,7 @@ extern FFS_DECLSPEC void cod_free_parse_context(cod_parse_context context);
  * \param externs the list of "name, external address" pairs to be
  *  associated.  This list should be terminated with a {NULL, 0} pair.
  */
-extern FFS_DECLSPEC void cod_assoc_externs(cod_parse_context context,
+extern void cod_assoc_externs(cod_parse_context context,
 				    cod_extern_list externs);
 
 /*!
@@ -151,7 +143,7 @@ extern FFS_DECLSPEC void cod_assoc_externs(cod_parse_context context,
  * 	"int proc(double d, int *i)"
  *  
  */
-extern FFS_DECLSPEC void
+extern void
 cod_subroutine_declaration(const char *decl, cod_parse_context context);
 
 /*!
@@ -163,7 +155,7 @@ cod_subroutine_declaration(const char *decl, cod_parse_context context);
  *  the structure.
  * \param context the context in which the type is to be made available.
  */
-extern FFS_DECLSPEC void cod_add_simple_struct_type(const char *name, FMFieldList field_list, 
+extern void cod_add_simple_struct_type(const char *name, FMFieldList field_list, 
 				       cod_parse_context context);
 
 /*!
@@ -174,7 +166,7 @@ extern FFS_DECLSPEC void cod_add_simple_struct_type(const char *name, FMFieldLis
  *  the structures.
  * \param context the context in which the type is to be made available.
  */
-extern FFS_DECLSPEC void cod_add_struct_type(FMStructDescList format_list, 
+extern void cod_add_struct_type(FMStructDescList format_list, 
 				cod_parse_context context);
 
 /*!
@@ -185,7 +177,7 @@ extern FFS_DECLSPEC void cod_add_struct_type(FMStructDescList format_list,
  * \param param_num the numeral of the new parameter (0 is first)
  * \param context the context in which the subroutine is being declared.
  */
-extern FFS_DECLSPEC void
+extern void
 cod_add_param(const char *id, const char *typ, int param_num, 
 	      cod_parse_context context);
 
@@ -199,7 +191,7 @@ cod_add_param(const char *id, const char *typ, int param_num,
  * \param context the context in which the subroutine is being declared.
  */
 #ifdef __FM__
-extern FFS_DECLSPEC void
+extern void
 cod_add_encoded_param(const char *id, char *data, int param_num, 
 		      FMContext c, cod_parse_context context);
 #endif
@@ -210,7 +202,7 @@ cod_add_encoded_param(const char *id, char *data, int param_num,
  * \param typ the data type of the return value.
  * \param context the context in which the subroutine is being declared.
  */
-extern FFS_DECLSPEC void
+extern void
 cod_set_return_type(char *typ, cod_parse_context context);
 
 /*!
@@ -263,7 +255,7 @@ int cod_code_verify(char *code, cod_parse_context context);
  *
  * \param code the handle to the resources that will be free'd.
  */
-extern FFS_DECLSPEC void cod_code_free(cod_code code);
+extern void cod_code_free(cod_code code);
 
 /*!
  * create an execution context associated with a code block
@@ -271,7 +263,7 @@ extern FFS_DECLSPEC void cod_code_free(cod_code code);
  * \param code the handle to the code bloc
  * \return the created execution context
  */
-extern FFS_DECLSPEC cod_exec_context cod_create_exec_context(cod_code code);
+extern cod_exec_context cod_create_exec_context(cod_code code);
 
 /*!
  * Free all resources associated with the generated code associated with the
@@ -279,7 +271,7 @@ extern FFS_DECLSPEC cod_exec_context cod_create_exec_context(cod_code code);
  *
  * \param code the handle to the resources that will be free'd.
  */
-extern FFS_DECLSPEC void cod_exec_context_free(cod_exec_context ec);
+extern void cod_exec_context_free(cod_exec_context ec);
 
 /*!
  * Associate application-level data with an execution context.  This is
@@ -291,7 +283,7 @@ extern FFS_DECLSPEC void cod_exec_context_free(cod_exec_context ec);
  * \param key the value that will serve as a key to retrieve the data
  * \param value the 'long' data that will be associated with the key
  */
-extern FFS_DECLSPEC void cod_assoc_client_data(cod_exec_context ec, int key, intptr_t value);
+extern void cod_assoc_client_data(cod_exec_context ec, int key, intptr_t value);
 
 /*!
  * Retrieve application-level data with an execution context.  This is
@@ -305,7 +297,7 @@ extern FFS_DECLSPEC void cod_assoc_client_data(cod_exec_context ec, int key, int
  * \param key the value that will serve as a key to retrieve the data
  * \return the 'long' data that was associated with the key
  */
-extern FFS_DECLSPEC intptr_t cod_get_client_data(cod_exec_context ec, int key);
+extern intptr_t cod_get_client_data(cod_exec_context ec, int key);
 
 /*!
  * Extract static state from an execution context.  
@@ -315,7 +307,7 @@ extern FFS_DECLSPEC intptr_t cod_get_client_data(cod_exec_context ec, int key);
  *  the length of the returned state block
  * \return a pointer to the extracted state
  */
-extern FFS_DECLSPEC void *cod_extract_state(cod_exec_context ec, int *length_p);
+extern void *cod_extract_state(cod_exec_context ec, int *length_p);
 
 /*!
  * Install static state into an execution context.  
@@ -325,7 +317,7 @@ extern FFS_DECLSPEC void *cod_extract_state(cod_exec_context ec, int *length_p);
  * \param state_size the size of the state block
  * \return 1 on success, 0 on failure
  */
-extern FFS_DECLSPEC int cod_install_state(cod_exec_context ec, void *state, int length);
+extern int cod_install_state(cod_exec_context ec, void *state, int length);
 
 /*!
  * \brief This parses a string to determine what external
@@ -356,7 +348,7 @@ int cod_parse_for_globals(char *code, cod_parse_context context);
  *
  * \param context the cod_parse_context to be duplicated.
  */
-extern FFS_DECLSPEC cod_parse_context cod_copy_context(cod_parse_context context);
+extern cod_parse_context cod_copy_context(cod_parse_context context);
 
 /*!
  * Duplicate a handle to an cod_parse_context, specifically adapting the results to 
@@ -365,7 +357,7 @@ extern FFS_DECLSPEC cod_parse_context cod_copy_context(cod_parse_context context
  *
  * \param context the cod_parse_context to be duplicated.
  */
-extern FFS_DECLSPEC cod_parse_context cod_copy_globals(cod_parse_context context);
+extern cod_parse_context cod_copy_globals(cod_parse_context context);
 
 /*!
  *  err_out_func_t is a function pointer type.   Functions matching this
@@ -408,7 +400,7 @@ void cod_dump(cod_code code);
  *  \param format2 the old format. This is the format of the output message.
  *  \param xform_code  The COD code string that transforms data from format1 to format2.
  */
-extern FFS_DECLSPEC cod_code
+extern cod_code
 gen_rollback_code(FMStructDescList format1, FMStructDescList format2, char *xform_code);
 
 /*!
@@ -417,7 +409,7 @@ gen_rollback_code(FMStructDescList format1, FMStructDescList format2, char *xfor
  * \param value The value of the constant
  * \param context the context in which this is to be created
 */
-extern FFS_DECLSPEC void cod_add_int_constant_to_parse_context(const char *id, int value,
+extern void cod_add_int_constant_to_parse_context(const char *id, int value,
     cod_parse_context context); 
 
 /*!
@@ -426,7 +418,7 @@ extern FFS_DECLSPEC void cod_add_int_constant_to_parse_context(const char *id, i
  * \param value The value to send
  * \param context The context in which the subroutine has been declared.
 */
-extern FFS_DECLSPEC void cod_set_closure(char *name, void* value, cod_parse_context context);
+extern void cod_set_closure(char *name, void* value, cod_parse_context context);
 
 #if defined(__cplusplus) || defined(c_plusplus)
 }
diff --git a/cod/cod.y b/cod/cod.y
index a4d0d17515..3d99807dcb 100644
--- a/cod/cod.y
+++ b/cod/cod.y
@@ -6447,7 +6447,7 @@ space_to_underscore(char *str){
     while(*str != '\0'){
 	if(isspace(*str))
 	    *str = '_';
-	    str++;
+	str++;
     }
 }
 
@@ -6732,7 +6732,7 @@ evaluate_constant_return_expr(cod_parse_context context, sm_ref expr, int *free_
 	    *free_result = 1;
 	} else {
 	    /* we get an integer result */
-	    intptr_t left_val = 0, right_val = 0, value;
+	    intptr_t left_val = 0, right_val = 0, value = 0;
 	    char str_val[40];
 	    if (expr->node.operator.left)
 		left_val = get_constant_long_value(context, left);
diff --git a/cod/pregen_source/Windows/cod.l b/cod/pregen_source/Windows/cod.l
index 724916d39c..6b816a740f 100644
--- a/cod/pregen_source/Windows/cod.l
+++ b/cod/pregen_source/Windows/cod.l
@@ -359,70 +359,9 @@ yywrap YY_PROTO(( void ))
 }
 
 
-#ifndef input
 /* flex, not lex */
 void yy_delete_buffer YY_PROTO((YY_BUFFER_STATE b));
 
-#ifdef WINNT
-/* old Windows code for MKS Toolkit version of flex */
-
-static void 
-terminate_string_parse()
-{
-    yyrestart(NULL);
-}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-static char* current_input_string;
-
-int my_yy_input(buf,result,max_size) {
-
-      if (current_input_string == NULL) 
-      {
-           
-           result = 0;
-      }
-      else
-           if (max_size < strlen(current_input_string)) 
-	   {
-	        memcpy((void*)buf, current_input_string, max_size);
-		current_input_string += max_size;
-		result = max_size;
-	   } else {
-	        int n = strlen(current_input_string);
-		memcpy((void*)buf, current_input_string, n+1);
-		current_input_string = NULL;
-		result = n;
-	   }
-      	  
-/*      printf("my_yy_input buf[%s],result[%d]\n",buf,result);*/
-      return result;
-}
-
-static void
-setup_for_string_parse(string, defined_types, enum_constants)
-const char *string;
-char **defined_types;
-char **enum_constants;
-{
-    type_count = defined_type_count;
-    types = defined_types;
-    enums = enum_constants;
-
-    current_input_string = string;
-    lex_offset = 1;
-    line_count = 1;
-}
-#else
 
 static YY_BUFFER_STATE bb = NULL;
 
@@ -455,5 +394,3 @@ terminate_string_parse()
 	}
 }
 
-#endif
-#endif
diff --git a/cod/pregen_source/Windows/cod.tab.c b/cod/pregen_source/Windows/cod.tab.c
index 531a170505..70198e7fba 100644
--- a/cod/pregen_source/Windows/cod.tab.c
+++ b/cod/pregen_source/Windows/cod.tab.c
@@ -289,138 +289,7 @@ cod_dup_list(sm_list list)
 #  endif
 # endif
 
-
-/* Debug traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-#if YYDEBUG
-extern int yydebug;
-#endif
-
-/* Token kinds.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-  enum yytokentype
-  {
-    YYEMPTY = -2,
-    YYEOF = 0,                     /* "end of file"  */
-    YYerror = 256,                 /* error  */
-    YYUNDEF = 257,                 /* "invalid token"  */
-    ARROW = 258,                   /* ARROW  */
-    LPAREN = 259,                  /* LPAREN  */
-    RPAREN = 260,                  /* RPAREN  */
-    LCURLY = 261,                  /* LCURLY  */
-    RCURLY = 262,                  /* RCURLY  */
-    COLON = 263,                   /* COLON  */
-    QUESTION = 264,                /* QUESTION  */
-    LBRACKET = 265,                /* LBRACKET  */
-    RBRACKET = 266,                /* RBRACKET  */
-    DOT = 267,                     /* DOT  */
-    STAR = 268,                    /* STAR  */
-    AT = 269,                      /* AT  */
-    SLASH = 270,                   /* SLASH  */
-    MODULUS = 271,                 /* MODULUS  */
-    PLUS = 272,                    /* PLUS  */
-    MINUS = 273,                   /* MINUS  */
-    TILDE = 274,                   /* TILDE  */
-    LEQ = 275,                     /* LEQ  */
-    LT = 276,                      /* LT  */
-    GEQ = 277,                     /* GEQ  */
-    GT = 278,                      /* GT  */
-    EQ = 279,                      /* EQ  */
-    NEQ = 280,                     /* NEQ  */
-    LEFT_SHIFT = 281,              /* LEFT_SHIFT  */
-    RIGHT_SHIFT = 282,             /* RIGHT_SHIFT  */
-    ASSIGN = 283,                  /* ASSIGN  */
-    MUL_ASSIGN = 284,              /* MUL_ASSIGN  */
-    DIV_ASSIGN = 285,              /* DIV_ASSIGN  */
-    MOD_ASSIGN = 286,              /* MOD_ASSIGN  */
-    ADD_ASSIGN = 287,              /* ADD_ASSIGN  */
-    SUB_ASSIGN = 288,              /* SUB_ASSIGN  */
-    LEFT_ASSIGN = 289,             /* LEFT_ASSIGN  */
-    RIGHT_ASSIGN = 290,            /* RIGHT_ASSIGN  */
-    AND_ASSIGN = 291,              /* AND_ASSIGN  */
-    XOR_ASSIGN = 292,              /* XOR_ASSIGN  */
-    OR_ASSIGN = 293,               /* OR_ASSIGN  */
-    LOG_OR = 294,                  /* LOG_OR  */
-    LOG_AND = 295,                 /* LOG_AND  */
-    ARITH_OR = 296,                /* ARITH_OR  */
-    ARITH_AND = 297,               /* ARITH_AND  */
-    ARITH_XOR = 298,               /* ARITH_XOR  */
-    INC_OP = 299,                  /* INC_OP  */
-    DEC_OP = 300,                  /* DEC_OP  */
-    BANG = 301,                    /* BANG  */
-    SEMI = 302,                    /* SEMI  */
-    IF = 303,                      /* IF  */
-    ELSE = 304,                    /* ELSE  */
-    FOR = 305,                     /* FOR  */
-    DO = 306,                      /* DO  */
-    WHILE = 307,                   /* WHILE  */
-    CHAR = 308,                    /* CHAR  */
-    SHORT = 309,                   /* SHORT  */
-    INT = 310,                     /* INT  */
-    LONG = 311,                    /* LONG  */
-    UNSIGNED = 312,                /* UNSIGNED  */
-    SIGNED = 313,                  /* SIGNED  */
-    FLOAT = 314,                   /* FLOAT  */
-    DOUBLE = 315,                  /* DOUBLE  */
-    VOID = 316,                    /* VOID  */
-    STRING = 317,                  /* STRING  */
-    STATIC = 318,                  /* STATIC  */
-    EXTERN_TOKEN = 319,            /* EXTERN_TOKEN  */
-    STRUCT = 320,                  /* STRUCT  */
-    ENUM = 321,                    /* ENUM  */
-    UNION = 322,                   /* UNION  */
-    CONST = 323,                   /* CONST  */
-    SIZEOF = 324,                  /* SIZEOF  */
-    TYPEDEF = 325,                 /* TYPEDEF  */
-    RETURN_TOKEN = 326,            /* RETURN_TOKEN  */
-    CONTINUE = 327,                /* CONTINUE  */
-    BREAK = 328,                   /* BREAK  */
-    GOTO = 329,                    /* GOTO  */
-    PRINT = 330,                   /* PRINT  */
-    COMMA = 331,                   /* COMMA  */
-    DOTDOTDOT = 332,               /* DOTDOTDOT  */
-    integer_constant = 333,        /* integer_constant  */
-    character_constant = 334,      /* character_constant  */
-    string_constant = 335,         /* string_constant  */
-    floating_constant = 336,       /* floating_constant  */
-    identifier_ref = 337,          /* identifier_ref  */
-    type_identifier = 338,                 /* type_id  */
-    enumeration_constant = 339     /* enumeration_constant  */
-  };
-  typedef enum yytokentype yytoken_kind_t;
-#endif
-
-/* Value type.  */
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-union YYSTYPE
-{
-#line 201 "cod.y"
-
-    lx_info info;
-    sm_ref reference;
-    operator_t operator;
-    sm_list list;
-    char *string;
-
-#line 409 "cod.tab.c"
-
-};
-typedef union YYSTYPE YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
-# define YYSTYPE_IS_DECLARED 1
-#endif
-
-
-extern YYSTYPE yylval;
-
-
-int yyparse (void);
-
-
-
+#include "cod.tab.h"
 /* Symbol kind.  */
 enum yysymbol_kind_t
 {
@@ -508,7 +377,7 @@ enum yysymbol_kind_t
   YYSYMBOL_string_constant = 80,           /* string_constant  */
   YYSYMBOL_floating_constant = 81,         /* floating_constant  */
   YYSYMBOL_identifier_ref = 82,            /* identifier_ref  */
-  YYSYMBOL_type_identifier = 83,                   /* type_id  */
+  YYSYMBOL_type_identifier = 83,           /* type_identifier  */
   YYSYMBOL_enumeration_constant = 84,      /* enumeration_constant  */
   YYSYMBOL_YYACCEPT = 85,                  /* $accept  */
   YYSYMBOL_start = 86,                     /* start  */
@@ -1019,18 +888,19 @@ static const char *const yytname[] =
   "ENUM", "UNION", "CONST", "SIZEOF", "TYPEDEF", "RETURN_TOKEN",
   "CONTINUE", "BREAK", "GOTO", "PRINT", "COMMA", "DOTDOTDOT",
   "integer_constant", "character_constant", "string_constant",
-  "floating_constant", "identifier_ref", "type_identifier", "enumeration_constant",
-  "$accept", "start", "primary_expression", "postfix_expression",
-  "argument_expression_list", "unary_expression", "unary_operator",
-  "cast_expression", "multiplicative_expression", "additive_expression",
-  "shift_expression", "relational_expression", "equality_expression",
-  "and_expression", "exclusive_or_expression", "inclusive_or_expression",
-  "logical_and_expression", "logical_or_expression",
-  "conditional_expression", "assignment_operator", "assignment_expression",
-  "expression", "constant_expression", "init_declarator_list",
-  "declaration", "$@1", "@2", "declaration_specifiers", "init_declarator",
-  "storage_class_specifier", "type_specifier", "struct_or_union_specifier",
-  "struct_or_union", "struct_declaration_list", "struct_declaration",
+  "floating_constant", "identifier_ref", "type_identifier",
+  "enumeration_constant", "$accept", "start", "primary_expression",
+  "postfix_expression", "argument_expression_list", "unary_expression",
+  "unary_operator", "cast_expression", "multiplicative_expression",
+  "additive_expression", "shift_expression", "relational_expression",
+  "equality_expression", "and_expression", "exclusive_or_expression",
+  "inclusive_or_expression", "logical_and_expression",
+  "logical_or_expression", "conditional_expression", "assignment_operator",
+  "assignment_expression", "expression", "constant_expression",
+  "init_declarator_list", "declaration", "$@1", "@2",
+  "declaration_specifiers", "init_declarator", "storage_class_specifier",
+  "type_specifier", "struct_or_union_specifier", "struct_or_union",
+  "struct_declaration_list", "struct_declaration",
   "struct_declarator_list", "struct_declarator",
   "specifier_qualifier_list", "enum_specifier", "enumerator_list",
   "enumerator", "type_qualifier", "declarator", "direct_declarator",
@@ -1928,7 +1798,7 @@ yyparse (void)
                          {
 	    yyparse_value = (sm_ref)(yyvsp[0].list);
 	}
-#line 1932 "cod.tab.c"
+#line 1802 "cod.tab.c"
     break;
 
   case 3: /* start: compound_statement  */
@@ -1936,7 +1806,7 @@ yyparse (void)
                            {
 	    yyparse_value = (yyvsp[0].reference);
 	}
-#line 1940 "cod.tab.c"
+#line 1810 "cod.tab.c"
     break;
 
   case 4: /* primary_expression: identifier_ref  */
@@ -1946,13 +1816,13 @@ yyparse (void)
 	    (yyval.reference)->node.identifier.id = (yyvsp[0].info).string;
 	    (yyval.reference)->node.identifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	}
-#line 1950 "cod.tab.c"
+#line 1820 "cod.tab.c"
     break;
 
   case 6: /* primary_expression: LPAREN expression RPAREN  */
 #line 377 "cod.y"
         { (yyval.reference) = (yyvsp[-1].reference); }
-#line 1956 "cod.tab.c"
+#line 1826 "cod.tab.c"
     break;
 
   case 8: /* postfix_expression: postfix_expression LBRACKET expression RBRACKET  */
@@ -1963,7 +1833,7 @@ yyparse (void)
 	    (yyval.reference)->node.element_ref.expression = (yyvsp[-1].reference);
 	    (yyval.reference)->node.element_ref.array_ref = (yyvsp[-3].reference);
 	}
-#line 1967 "cod.tab.c"
+#line 1837 "cod.tab.c"
     break;
 
   case 9: /* postfix_expression: postfix_expression DOT identifier_ref  */
@@ -1974,7 +1844,7 @@ yyparse (void)
 	    (yyval.reference)->node.field_ref.lx_field = (yyvsp[0].info).string;
 	    (yyval.reference)->node.field_ref.struct_ref = (yyvsp[-2].reference);
 	}
-#line 1978 "cod.tab.c"
+#line 1848 "cod.tab.c"
     break;
 
   case 10: /* postfix_expression: postfix_expression LPAREN argument_expression_list RPAREN  */
@@ -1985,7 +1855,7 @@ yyparse (void)
 	    (yyval.reference)->node.subroutine_call.arguments = (yyvsp[-1].list);
 	    (yyval.reference)->node.subroutine_call.sm_func_ref = (yyvsp[-3].reference);
 	}
-#line 1989 "cod.tab.c"
+#line 1859 "cod.tab.c"
     break;
 
   case 11: /* postfix_expression: postfix_expression LPAREN RPAREN  */
@@ -1996,7 +1866,7 @@ yyparse (void)
 	    (yyval.reference)->node.subroutine_call.arguments = NULL;
 	    (yyval.reference)->node.subroutine_call.sm_func_ref = (yyvsp[-2].reference);
 	}
-#line 2000 "cod.tab.c"
+#line 1870 "cod.tab.c"
     break;
 
   case 12: /* postfix_expression: postfix_expression ARROW identifier_ref  */
@@ -2007,7 +1877,7 @@ yyparse (void)
 	    (yyval.reference)->node.field_ref.lx_field = (yyvsp[0].info).string;
 	    (yyval.reference)->node.field_ref.struct_ref = (yyvsp[-2].reference);
 	}
-#line 2011 "cod.tab.c"
+#line 1881 "cod.tab.c"
     break;
 
   case 13: /* postfix_expression: postfix_expression INC_OP  */
@@ -2019,7 +1889,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = NULL;
 	    (yyval.reference)->node.operator.left = (yyvsp[-1].reference);
 	}
-#line 2023 "cod.tab.c"
+#line 1893 "cod.tab.c"
     break;
 
   case 14: /* postfix_expression: postfix_expression DEC_OP  */
@@ -2031,7 +1901,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = NULL;
 	    (yyval.reference)->node.operator.left = (yyvsp[-1].reference);
 	}
-#line 2035 "cod.tab.c"
+#line 1905 "cod.tab.c"
     break;
 
   case 15: /* argument_expression_list: assignment_expression  */
@@ -2041,7 +1911,7 @@ yyparse (void)
 		(yyval.list)->node = (yyvsp[0].reference);
 		(yyval.list)->next = NULL;
 	}
-#line 2045 "cod.tab.c"
+#line 1915 "cod.tab.c"
     break;
 
   case 16: /* argument_expression_list: argument_expression_list COMMA assignment_expression  */
@@ -2056,7 +1926,7 @@ yyparse (void)
 	    tmp->next->next = NULL;
 	    (yyval.list) = (yyvsp[-2].list);
 	}
-#line 2060 "cod.tab.c"
+#line 1930 "cod.tab.c"
     break;
 
   case 18: /* unary_expression: INC_OP unary_expression  */
@@ -2068,7 +1938,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = NULL;
 	}
-#line 2072 "cod.tab.c"
+#line 1942 "cod.tab.c"
     break;
 
   case 19: /* unary_expression: DEC_OP unary_expression  */
@@ -2080,7 +1950,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = NULL;
 	}
-#line 2084 "cod.tab.c"
+#line 1954 "cod.tab.c"
     break;
 
   case 20: /* unary_expression: unary_operator cast_expression  */
@@ -2092,7 +1962,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = NULL;
 	}
-#line 2096 "cod.tab.c"
+#line 1966 "cod.tab.c"
     break;
 
   case 21: /* unary_expression: SIZEOF unary_expression  */
@@ -2104,7 +1974,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = NULL;
 	}
-#line 2108 "cod.tab.c"
+#line 1978 "cod.tab.c"
     break;
 
   case 22: /* unary_expression: SIZEOF LPAREN type_name RPAREN  */
@@ -2122,7 +1992,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = cast;
 	    (yyval.reference)->node.operator.left = NULL;
 	}
-#line 2126 "cod.tab.c"
+#line 1996 "cod.tab.c"
     break;
 
   case 23: /* unary_operator: ARITH_AND  */
@@ -2130,7 +2000,7 @@ yyparse (void)
                     {
 	    (yyval.info).op = op_address;
 	}
-#line 2134 "cod.tab.c"
+#line 2004 "cod.tab.c"
     break;
 
   case 24: /* unary_operator: STAR  */
@@ -2138,7 +2008,7 @@ yyparse (void)
                {
 	    (yyval.info).op = op_deref;
 	}
-#line 2142 "cod.tab.c"
+#line 2012 "cod.tab.c"
     break;
 
   case 25: /* unary_operator: PLUS  */
@@ -2146,7 +2016,7 @@ yyparse (void)
                {
 	    (yyval.info).op = op_plus;
 	}
-#line 2150 "cod.tab.c"
+#line 2020 "cod.tab.c"
     break;
 
   case 26: /* unary_operator: MINUS  */
@@ -2154,7 +2024,7 @@ yyparse (void)
                 {
 	    (yyval.info).op = op_minus;
 	}
-#line 2158 "cod.tab.c"
+#line 2028 "cod.tab.c"
     break;
 
   case 27: /* unary_operator: TILDE  */
@@ -2162,7 +2032,7 @@ yyparse (void)
                 {
 	    (yyval.info).op = op_not;
 	}
-#line 2166 "cod.tab.c"
+#line 2036 "cod.tab.c"
     break;
 
   case 28: /* unary_operator: BANG  */
@@ -2170,7 +2040,7 @@ yyparse (void)
                {
 	    (yyval.info).op = op_log_neg;
 	  }
-#line 2174 "cod.tab.c"
+#line 2044 "cod.tab.c"
     break;
 
   case 30: /* cast_expression: LPAREN type_name RPAREN cast_expression  */
@@ -2181,7 +2051,7 @@ yyparse (void)
 	    (yyval.reference)->node.cast.type_spec = (yyvsp[-2].list);
 	    (yyval.reference)->node.cast.expression = (yyvsp[0].reference);
 	}
-#line 2185 "cod.tab.c"
+#line 2055 "cod.tab.c"
     break;
 
   case 32: /* multiplicative_expression: multiplicative_expression STAR cast_expression  */
@@ -2193,7 +2063,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2197 "cod.tab.c"
+#line 2067 "cod.tab.c"
     break;
 
   case 33: /* multiplicative_expression: multiplicative_expression SLASH cast_expression  */
@@ -2205,7 +2075,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2209 "cod.tab.c"
+#line 2079 "cod.tab.c"
     break;
 
   case 34: /* multiplicative_expression: multiplicative_expression MODULUS cast_expression  */
@@ -2217,7 +2087,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2221 "cod.tab.c"
+#line 2091 "cod.tab.c"
     break;
 
   case 36: /* additive_expression: additive_expression PLUS multiplicative_expression  */
@@ -2229,7 +2099,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2233 "cod.tab.c"
+#line 2103 "cod.tab.c"
     break;
 
   case 37: /* additive_expression: additive_expression MINUS multiplicative_expression  */
@@ -2241,7 +2111,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2245 "cod.tab.c"
+#line 2115 "cod.tab.c"
     break;
 
   case 39: /* shift_expression: shift_expression LEFT_SHIFT additive_expression  */
@@ -2253,7 +2123,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2257 "cod.tab.c"
+#line 2127 "cod.tab.c"
     break;
 
   case 40: /* shift_expression: shift_expression RIGHT_SHIFT additive_expression  */
@@ -2265,7 +2135,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2269 "cod.tab.c"
+#line 2139 "cod.tab.c"
     break;
 
   case 42: /* relational_expression: relational_expression LT shift_expression  */
@@ -2277,7 +2147,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2281 "cod.tab.c"
+#line 2151 "cod.tab.c"
     break;
 
   case 43: /* relational_expression: relational_expression GT shift_expression  */
@@ -2289,7 +2159,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2293 "cod.tab.c"
+#line 2163 "cod.tab.c"
     break;
 
   case 44: /* relational_expression: relational_expression LEQ shift_expression  */
@@ -2301,7 +2171,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2305 "cod.tab.c"
+#line 2175 "cod.tab.c"
     break;
 
   case 45: /* relational_expression: relational_expression GEQ shift_expression  */
@@ -2313,7 +2183,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2317 "cod.tab.c"
+#line 2187 "cod.tab.c"
     break;
 
   case 47: /* equality_expression: equality_expression EQ relational_expression  */
@@ -2325,7 +2195,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2329 "cod.tab.c"
+#line 2199 "cod.tab.c"
     break;
 
   case 48: /* equality_expression: equality_expression NEQ relational_expression  */
@@ -2337,7 +2207,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2341 "cod.tab.c"
+#line 2211 "cod.tab.c"
     break;
 
   case 50: /* and_expression: and_expression ARITH_AND equality_expression  */
@@ -2349,7 +2219,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2353 "cod.tab.c"
+#line 2223 "cod.tab.c"
     break;
 
   case 52: /* exclusive_or_expression: exclusive_or_expression ARITH_XOR and_expression  */
@@ -2361,7 +2231,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2365 "cod.tab.c"
+#line 2235 "cod.tab.c"
     break;
 
   case 54: /* inclusive_or_expression: inclusive_or_expression ARITH_OR exclusive_or_expression  */
@@ -2373,7 +2243,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2377 "cod.tab.c"
+#line 2247 "cod.tab.c"
     break;
 
   case 56: /* logical_and_expression: logical_and_expression LOG_AND inclusive_or_expression  */
@@ -2385,7 +2255,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2389 "cod.tab.c"
+#line 2259 "cod.tab.c"
     break;
 
   case 58: /* logical_or_expression: logical_or_expression LOG_OR logical_and_expression  */
@@ -2397,7 +2267,7 @@ yyparse (void)
 	    (yyval.reference)->node.operator.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.operator.left = (yyvsp[-2].reference);
 	}
-#line 2401 "cod.tab.c"
+#line 2271 "cod.tab.c"
     break;
 
   case 60: /* conditional_expression: logical_or_expression QUESTION expression COLON conditional_expression  */
@@ -2409,79 +2279,79 @@ yyparse (void)
 	    (yyval.reference)->node.conditional_operator.e1 = (yyvsp[-2].reference);
 	    (yyval.reference)->node.conditional_operator.e2 = (yyvsp[0].reference);
 	}
-#line 2413 "cod.tab.c"
+#line 2283 "cod.tab.c"
     break;
 
   case 61: /* assignment_operator: ASSIGN  */
 #line 746 "cod.y"
         { (yyval.info) = (yyvsp[0].info); (yyval.info).op = op_eq;}
-#line 2419 "cod.tab.c"
+#line 2289 "cod.tab.c"
     break;
 
   case 62: /* assignment_operator: MUL_ASSIGN  */
 #line 748 "cod.y"
         { (yyval.info) = (yyvsp[0].info); (yyval.info).op = op_mult;}
-#line 2425 "cod.tab.c"
+#line 2295 "cod.tab.c"
     break;
 
   case 63: /* assignment_operator: DIV_ASSIGN  */
 #line 750 "cod.y"
         { (yyval.info) = (yyvsp[0].info); (yyval.info).op = op_div;}
-#line 2431 "cod.tab.c"
+#line 2301 "cod.tab.c"
     break;
 
   case 64: /* assignment_operator: MOD_ASSIGN  */
 #line 752 "cod.y"
         { (yyval.info) = (yyvsp[0].info); (yyval.info).op = op_modulus;}
-#line 2437 "cod.tab.c"
+#line 2307 "cod.tab.c"
     break;
 
   case 65: /* assignment_operator: ADD_ASSIGN  */
 #line 754 "cod.y"
         { (yyval.info) = (yyvsp[0].info); (yyval.info).op = op_plus;}
-#line 2443 "cod.tab.c"
+#line 2313 "cod.tab.c"
     break;
 
   case 66: /* assignment_operator: SUB_ASSIGN  */
 #line 756 "cod.y"
         { (yyval.info) = (yyvsp[0].info); (yyval.info).op = op_minus;}
-#line 2449 "cod.tab.c"
+#line 2319 "cod.tab.c"
     break;
 
   case 67: /* assignment_operator: LEFT_ASSIGN  */
 #line 758 "cod.y"
         { (yyval.info) = (yyvsp[0].info); (yyval.info).op = op_left_shift;}
-#line 2455 "cod.tab.c"
+#line 2325 "cod.tab.c"
     break;
 
   case 68: /* assignment_operator: RIGHT_ASSIGN  */
 #line 760 "cod.y"
         { (yyval.info) = (yyvsp[0].info); (yyval.info).op = op_right_shift;}
-#line 2461 "cod.tab.c"
+#line 2331 "cod.tab.c"
     break;
 
   case 69: /* assignment_operator: AND_ASSIGN  */
 #line 762 "cod.y"
         { (yyval.info) = (yyvsp[0].info); (yyval.info).op = op_arith_and;}
-#line 2467 "cod.tab.c"
+#line 2337 "cod.tab.c"
     break;
 
   case 70: /* assignment_operator: XOR_ASSIGN  */
 #line 764 "cod.y"
         { (yyval.info) = (yyvsp[0].info); (yyval.info).op = op_arith_xor;}
-#line 2473 "cod.tab.c"
+#line 2343 "cod.tab.c"
     break;
 
   case 71: /* assignment_operator: OR_ASSIGN  */
 #line 766 "cod.y"
         { (yyval.info) = (yyvsp[0].info); (yyval.info).op = op_arith_or;}
-#line 2479 "cod.tab.c"
+#line 2349 "cod.tab.c"
     break;
 
   case 72: /* assignment_expression: conditional_expression  */
 #line 771 "cod.y"
         { (yyval.reference) = (yyvsp[0].reference);}
-#line 2485 "cod.tab.c"
+#line 2355 "cod.tab.c"
     break;
 
   case 73: /* assignment_expression: unary_expression assignment_operator assignment_expression  */
@@ -2493,13 +2363,13 @@ yyparse (void)
 	    (yyval.reference)->node.assignment_expression.right = (yyvsp[0].reference);
 	    (yyval.reference)->node.assignment_expression.op = (yyvsp[-1].info).op;
 	}
-#line 2497 "cod.tab.c"
+#line 2367 "cod.tab.c"
     break;
 
   case 74: /* expression: assignment_expression  */
 #line 785 "cod.y"
             {(yyval.reference) = (yyvsp[0].reference);}
-#line 2503 "cod.tab.c"
+#line 2373 "cod.tab.c"
     break;
 
   case 75: /* expression: expression COMMA assignment_expression  */
@@ -2510,7 +2380,7 @@ yyparse (void)
 	    (yyval.reference)->node.comma_expression.left = (yyvsp[-2].reference);
 	    (yyval.reference)->node.comma_expression.right = (yyvsp[0].reference);
 	}
-#line 2514 "cod.tab.c"
+#line 2384 "cod.tab.c"
     break;
 
   case 77: /* init_declarator_list: init_declarator  */
@@ -2520,7 +2390,7 @@ yyparse (void)
 		(yyval.list)->node = (yyvsp[0].reference);
 		(yyval.list)->next = NULL;
 	}
-#line 2524 "cod.tab.c"
+#line 2394 "cod.tab.c"
     break;
 
   case 78: /* init_declarator_list: init_declarator_list COMMA init_declarator  */
@@ -2536,7 +2406,7 @@ yyparse (void)
 	    tmp->next = NULL;
 	    (yyval.list) = (yyvsp[-2].list);
 	}
-#line 2540 "cod.tab.c"
+#line 2410 "cod.tab.c"
     break;
 
   case 79: /* $@1: %empty  */
@@ -2547,7 +2417,7 @@ yyparse (void)
 		     YYACCEPT;
 		 }
 	     }
-#line 2551 "cod.tab.c"
+#line 2421 "cod.tab.c"
     break;
 
   case 80: /* @2: %empty  */
@@ -2579,7 +2449,7 @@ yyparse (void)
 		    YYACCEPT;
 		}
 	    }
-#line 2583 "cod.tab.c"
+#line 2453 "cod.tab.c"
     break;
 
   case 81: /* declaration: declaration_specifiers $@1 init_declarator_list @2 SEMI  */
@@ -2639,7 +2509,7 @@ yyparse (void)
 		}
 		(void)(yyvsp[-1].reference);
 	    }
-#line 2643 "cod.tab.c"
+#line 2513 "cod.tab.c"
     break;
 
   case 82: /* declaration: declaration_specifiers SEMI  */
@@ -2647,7 +2517,7 @@ yyparse (void)
                                       {
 	    (yyval.list) = (yyvsp[-1].list);
 	}
-#line 2651 "cod.tab.c"
+#line 2521 "cod.tab.c"
     break;
 
   case 83: /* declaration_specifiers: storage_class_specifier  */
@@ -2657,7 +2527,7 @@ yyparse (void)
 	    (yyval.list)->node = (yyvsp[0].reference);
 	    (yyval.list)->next = NULL;
 	}
-#line 2661 "cod.tab.c"
+#line 2531 "cod.tab.c"
     break;
 
   case 84: /* declaration_specifiers: storage_class_specifier declaration_specifiers  */
@@ -2668,7 +2538,7 @@ yyparse (void)
 	    tmp->next = (yyvsp[0].list);
 	    (yyval.list) = tmp;
 	}
-#line 2672 "cod.tab.c"
+#line 2542 "cod.tab.c"
     break;
 
   case 85: /* declaration_specifiers: type_specifier  */
@@ -2678,7 +2548,7 @@ yyparse (void)
 	    (yyval.list)->node = (yyvsp[0].reference);
 	    (yyval.list)->next = NULL;
 	}
-#line 2682 "cod.tab.c"
+#line 2552 "cod.tab.c"
     break;
 
   case 86: /* declaration_specifiers: type_specifier declaration_specifiers  */
@@ -2689,7 +2559,7 @@ yyparse (void)
 	    tmp->next = (yyvsp[0].list);
 	    (yyval.list) = tmp;
 	}
-#line 2693 "cod.tab.c"
+#line 2563 "cod.tab.c"
     break;
 
   case 87: /* declaration_specifiers: type_qualifier  */
@@ -2699,7 +2569,7 @@ yyparse (void)
 	    (yyval.list)->node = (yyvsp[0].reference);
 	    (yyval.list)->next = NULL;
 	}
-#line 2703 "cod.tab.c"
+#line 2573 "cod.tab.c"
     break;
 
   case 88: /* declaration_specifiers: type_qualifier declaration_specifiers  */
@@ -2710,7 +2580,7 @@ yyparse (void)
 	    tmp->next = (yyvsp[0].list);
 	    (yyval.list) = tmp;
 	}
-#line 2714 "cod.tab.c"
+#line 2584 "cod.tab.c"
     break;
 
   case 90: /* init_declarator: declarator ASSIGN initializer  */
@@ -2727,7 +2597,7 @@ yyparse (void)
 		    tmp->node.declaration.init_value = (yyvsp[0].reference);
 		}
 	    }
-#line 2731 "cod.tab.c"
+#line 2601 "cod.tab.c"
     break;
 
   case 91: /* storage_class_specifier: TYPEDEF  */
@@ -2737,7 +2607,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = TYPEDEF;
 	}
-#line 2741 "cod.tab.c"
+#line 2611 "cod.tab.c"
     break;
 
   case 92: /* storage_class_specifier: STATIC  */
@@ -2747,7 +2617,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = STATIC;
 	}
-#line 2751 "cod.tab.c"
+#line 2621 "cod.tab.c"
     break;
 
   case 93: /* storage_class_specifier: EXTERN_TOKEN  */
@@ -2757,7 +2627,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = EXTERN_TOKEN;
 	}
-#line 2761 "cod.tab.c"
+#line 2631 "cod.tab.c"
     break;
 
   case 94: /* type_specifier: CHAR  */
@@ -2767,7 +2637,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = CHAR;
 	}
-#line 2771 "cod.tab.c"
+#line 2641 "cod.tab.c"
     break;
 
   case 95: /* type_specifier: SHORT  */
@@ -2777,7 +2647,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = SHORT;
 	}
-#line 2781 "cod.tab.c"
+#line 2651 "cod.tab.c"
     break;
 
   case 96: /* type_specifier: INT  */
@@ -2787,7 +2657,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = INT;
 	}
-#line 2791 "cod.tab.c"
+#line 2661 "cod.tab.c"
     break;
 
   case 97: /* type_specifier: LONG  */
@@ -2797,7 +2667,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = LONG;
 	}
-#line 2801 "cod.tab.c"
+#line 2671 "cod.tab.c"
     break;
 
   case 98: /* type_specifier: FLOAT  */
@@ -2807,7 +2677,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = FLOAT;
 	}
-#line 2811 "cod.tab.c"
+#line 2681 "cod.tab.c"
     break;
 
   case 99: /* type_specifier: DOUBLE  */
@@ -2817,7 +2687,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = DOUBLE;
 	}
-#line 2821 "cod.tab.c"
+#line 2691 "cod.tab.c"
     break;
 
   case 100: /* type_specifier: VOID  */
@@ -2827,7 +2697,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = VOID;
 	}
-#line 2831 "cod.tab.c"
+#line 2701 "cod.tab.c"
     break;
 
   case 101: /* type_specifier: SIGNED  */
@@ -2837,7 +2707,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = SIGNED;
 	}
-#line 2841 "cod.tab.c"
+#line 2711 "cod.tab.c"
     break;
 
   case 102: /* type_specifier: UNSIGNED  */
@@ -2847,7 +2717,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = UNSIGNED;
 	}
-#line 2851 "cod.tab.c"
+#line 2721 "cod.tab.c"
     break;
 
   case 103: /* type_specifier: STRING  */
@@ -2857,17 +2727,17 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = STRING;
 	}
-#line 2861 "cod.tab.c"
+#line 2731 "cod.tab.c"
     break;
 
   case 104: /* type_specifier: type_identifier  */
 #line 1042 "cod.y"
-                  {
+                          {
 	    (yyval.reference) = cod_new_identifier();
 	    (yyval.reference)->node.identifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.identifier.id = (yyvsp[0].info).string;
 	}
-#line 2871 "cod.tab.c"
+#line 2741 "cod.tab.c"
     break;
 
   case 105: /* type_specifier: struct_or_union_specifier  */
@@ -2875,7 +2745,7 @@ yyparse (void)
                                     {
 	    (yyval.reference) = (yyvsp[0].reference);
 	}
-#line 2879 "cod.tab.c"
+#line 2749 "cod.tab.c"
     break;
 
   case 106: /* type_specifier: enum_specifier  */
@@ -2883,7 +2753,7 @@ yyparse (void)
                          {
 	    (yyval.reference) = (yyvsp[0].reference);
 	}
-#line 2887 "cod.tab.c"
+#line 2757 "cod.tab.c"
     break;
 
   case 107: /* struct_or_union_specifier: struct_or_union identifier_ref LCURLY struct_declaration_list RCURLY  */
@@ -2891,7 +2761,7 @@ yyparse (void)
                                                                                {
 	    (yyval.reference) = cod_build_parsed_type_node(yycontext, (yyvsp[-3].info).string, (yyvsp[-1].list));
 	}
-#line 2895 "cod.tab.c"
+#line 2765 "cod.tab.c"
     break;
 
   case 108: /* struct_or_union_specifier: struct_or_union LCURLY struct_declaration_list RCURLY  */
@@ -2899,7 +2769,7 @@ yyparse (void)
                                                                 {
 	    (yyval.reference) = cod_build_parsed_type_node(yycontext, strdup("anon"), (yyvsp[-1].list));
 	}
-#line 2903 "cod.tab.c"
+#line 2773 "cod.tab.c"
     break;
 
   case 109: /* struct_or_union_specifier: struct_or_union identifier_ref  */
@@ -2907,7 +2777,7 @@ yyparse (void)
                                          {
 	    (yyval.reference) = cod_build_parsed_type_node(yycontext, (yyvsp[0].info).string, NULL);
 	}
-#line 2911 "cod.tab.c"
+#line 2781 "cod.tab.c"
     break;
 
   case 111: /* struct_or_union: UNION  */
@@ -2915,7 +2785,7 @@ yyparse (void)
                 {
             yyerror("UNIONs not supported!");
 	}
-#line 2919 "cod.tab.c"
+#line 2789 "cod.tab.c"
     break;
 
   case 113: /* struct_declaration_list: struct_declaration_list struct_declaration  */
@@ -2928,13 +2798,13 @@ yyparse (void)
 	    tmp->next =(yyvsp[0].list);
 	    (yyval.list) = (yyvsp[-1].list);
 	}
-#line 2932 "cod.tab.c"
+#line 2802 "cod.tab.c"
     break;
 
   case 114: /* struct_declaration: specifier_qualifier_list SEMI  */
 #line 1088 "cod.y"
                                         { }
-#line 2938 "cod.tab.c"
+#line 2808 "cod.tab.c"
     break;
 
   case 115: /* struct_declaration: specifier_qualifier_list struct_declarator_list SEMI  */
@@ -2986,7 +2856,7 @@ yyparse (void)
 		}
 	    }
 	}
-#line 2990 "cod.tab.c"
+#line 2860 "cod.tab.c"
     break;
 
   case 116: /* struct_declarator_list: struct_declarator  */
@@ -2996,7 +2866,7 @@ yyparse (void)
 	    (yyval.list)->node = (yyvsp[0].reference);
 	    (yyval.list)->next = NULL;
 	}
-#line 3000 "cod.tab.c"
+#line 2870 "cod.tab.c"
     break;
 
   case 117: /* struct_declarator_list: struct_declarator_list COMMA struct_declarator  */
@@ -3011,7 +2881,7 @@ yyparse (void)
 	    tmp->next->next = NULL;
 	    (yyval.list) = (yyvsp[-2].list);
 	}
-#line 3015 "cod.tab.c"
+#line 2885 "cod.tab.c"
     break;
 
   case 119: /* specifier_qualifier_list: type_specifier specifier_qualifier_list  */
@@ -3022,7 +2892,7 @@ yyparse (void)
 	    tmp->next = (yyvsp[0].list);
 	    (yyval.list) = tmp;
 	}
-#line 3026 "cod.tab.c"
+#line 2896 "cod.tab.c"
     break;
 
   case 120: /* specifier_qualifier_list: type_specifier  */
@@ -3032,7 +2902,7 @@ yyparse (void)
 	    (yyval.list)->node = (yyvsp[0].reference);
 	    (yyval.list)->next = NULL;
 	}
-#line 3036 "cod.tab.c"
+#line 2906 "cod.tab.c"
     break;
 
   case 121: /* specifier_qualifier_list: type_qualifier specifier_qualifier_list  */
@@ -3043,7 +2913,7 @@ yyparse (void)
 	    tmp->next = (yyvsp[0].list);
 	    (yyval.list) = tmp;
 	}
-#line 3047 "cod.tab.c"
+#line 2917 "cod.tab.c"
     break;
 
   case 122: /* specifier_qualifier_list: type_qualifier  */
@@ -3053,7 +2923,7 @@ yyparse (void)
 	    (yyval.list)->node = (yyvsp[0].reference);
 	    (yyval.list)->next = NULL;
 	}
-#line 3057 "cod.tab.c"
+#line 2927 "cod.tab.c"
     break;
 
   case 123: /* enum_specifier: ENUM LCURLY enumerator_list RCURLY  */
@@ -3065,7 +2935,7 @@ yyparse (void)
 	    (yyval.reference)->node.enum_type_decl.lx_srcpos = (yyvsp[-3].info).lx_srcpos;
 	    // cod_add_defined_type(decl->node.declaration.id, yycontext);
 	}
-#line 3069 "cod.tab.c"
+#line 2939 "cod.tab.c"
     break;
 
   case 124: /* enum_specifier: ENUM LCURLY enumerator_list COMMA RCURLY  */
@@ -3077,7 +2947,7 @@ yyparse (void)
 	    (yyval.reference)->node.enum_type_decl.lx_srcpos = (yyvsp[-4].info).lx_srcpos;
 	    // cod_add_defined_type(decl->node.declaration.id, yycontext);
 	}
-#line 3081 "cod.tab.c"
+#line 2951 "cod.tab.c"
     break;
 
   case 125: /* enum_specifier: ENUM identifier_ref LCURLY enumerator_list RCURLY  */
@@ -3089,7 +2959,7 @@ yyparse (void)
 	    (yyval.reference)->node.enum_type_decl.lx_srcpos = (yyvsp[-4].info).lx_srcpos;
 	    // cod_add_defined_type(decl->node.declaration.id, yycontext);
 	}
-#line 3093 "cod.tab.c"
+#line 2963 "cod.tab.c"
     break;
 
   case 126: /* enum_specifier: ENUM identifier_ref LCURLY enumerator_list COMMA RCURLY  */
@@ -3101,7 +2971,7 @@ yyparse (void)
 	    (yyval.reference)->node.enum_type_decl.lx_srcpos = (yyvsp[-5].info).lx_srcpos;
 	    // cod_add_defined_type(decl->node.declaration.id, yycontext);
 	}
-#line 3105 "cod.tab.c"
+#line 2975 "cod.tab.c"
     break;
 
   case 127: /* enum_specifier: ENUM identifier_ref  */
@@ -3113,7 +2983,7 @@ yyparse (void)
 	    (yyval.reference)->node.enum_type_decl.lx_srcpos = (yyvsp[-1].info).lx_srcpos;
 	    // cod_add_defined_type(decl->node.declaration.id, yycontext);
 	}
-#line 3117 "cod.tab.c"
+#line 2987 "cod.tab.c"
     break;
 
   case 128: /* enumerator_list: enumerator  */
@@ -3124,7 +2994,7 @@ yyparse (void)
 	    tmp->next = NULL;
 	    (yyval.list) = tmp;
 	}
-#line 3128 "cod.tab.c"
+#line 2998 "cod.tab.c"
     break;
 
   case 129: /* enumerator_list: enumerator_list COMMA enumerator  */
@@ -3135,7 +3005,7 @@ yyparse (void)
 	    tmp->next = (yyvsp[-2].list);
 	    (yyval.list) = tmp;
 	}
-#line 3139 "cod.tab.c"
+#line 3009 "cod.tab.c"
     break;
 
   case 130: /* enumerator: identifier_ref ASSIGN constant_expression  */
@@ -3145,7 +3015,7 @@ yyparse (void)
 	    (yyval.reference)->node.enumerator.id = (yyvsp[-2].info).string;
 	    (yyval.reference)->node.enumerator.const_expression = (yyvsp[0].reference);
 	}
-#line 3149 "cod.tab.c"
+#line 3019 "cod.tab.c"
     break;
 
   case 131: /* enumerator: identifier_ref  */
@@ -3155,7 +3025,7 @@ yyparse (void)
 	    (yyval.reference)->node.enumerator.id = (yyvsp[0].info).string;
 	    (yyval.reference)->node.enumerator.const_expression = NULL;
 	}
-#line 3159 "cod.tab.c"
+#line 3029 "cod.tab.c"
     break;
 
   case 132: /* type_qualifier: CONST  */
@@ -3165,7 +3035,7 @@ yyparse (void)
 	    (yyval.reference)->node.type_specifier.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	    (yyval.reference)->node.type_specifier.token = CONST;
 	}
-#line 3169 "cod.tab.c"
+#line 3039 "cod.tab.c"
     break;
 
   case 134: /* declarator: pointer direct_declarator  */
@@ -3181,7 +3051,7 @@ yyparse (void)
 		cod_print((yyval.reference));
 	    }
 	}
-#line 3185 "cod.tab.c"
+#line 3055 "cod.tab.c"
     break;
 
   case 135: /* direct_declarator: identifier_ref  */
@@ -3195,7 +3065,7 @@ yyparse (void)
 		(yyval.reference)->node.declaration.is_subroutine = 0;
 		(yyval.reference)->node.declaration.params = NULL;
 	    }
-#line 3199 "cod.tab.c"
+#line 3069 "cod.tab.c"
     break;
 
   case 136: /* direct_declarator: LPAREN declarator RPAREN  */
@@ -3203,7 +3073,7 @@ yyparse (void)
                                    {
 	    (yyval.reference) = (yyvsp[-1].reference);
 	}
-#line 3207 "cod.tab.c"
+#line 3077 "cod.tab.c"
     break;
 
   case 137: /* direct_declarator: identifier_ref LPAREN parameter_type_list RPAREN  */
@@ -3217,7 +3087,7 @@ yyparse (void)
 		(yyval.reference)->node.declaration.is_subroutine = 1;
 		(yyval.reference)->node.declaration.params = (yyvsp[-1].list);
 	}
-#line 3221 "cod.tab.c"
+#line 3091 "cod.tab.c"
     break;
 
   case 138: /* direct_declarator: identifier_ref LPAREN RPAREN  */
@@ -3231,7 +3101,7 @@ yyparse (void)
 		(yyval.reference)->node.declaration.is_subroutine = 1;
 		(yyval.reference)->node.declaration.params = NULL;
 	}
-#line 3235 "cod.tab.c"
+#line 3105 "cod.tab.c"
     break;
 
   case 139: /* direct_declarator: direct_declarator LBRACKET constant_expression RBRACKET  */
@@ -3243,7 +3113,7 @@ yyparse (void)
 		(yyval.reference)->node.array_type_decl.element_ref = (yyvsp[-3].reference);
 		(yyval.reference)->node.array_type_decl.sm_dynamic_size = NULL;
 	}
-#line 3247 "cod.tab.c"
+#line 3117 "cod.tab.c"
     break;
 
   case 140: /* direct_declarator: direct_declarator LBRACKET RBRACKET  */
@@ -3255,7 +3125,7 @@ yyparse (void)
 		(yyval.reference)->node.array_type_decl.element_ref = (yyvsp[-2].reference);
 		(yyval.reference)->node.array_type_decl.sm_dynamic_size = NULL;
 	}
-#line 3259 "cod.tab.c"
+#line 3129 "cod.tab.c"
     break;
 
   case 141: /* pointer: STAR  */
@@ -3268,7 +3138,7 @@ yyparse (void)
 	    (yyval.list)->node = star;
 	    (yyval.list)->next = NULL;
 	}
-#line 3272 "cod.tab.c"
+#line 3142 "cod.tab.c"
     break;
 
   case 142: /* pointer: STAR type_qualifier_list  */
@@ -3281,7 +3151,7 @@ yyparse (void)
 	    (yyval.list)->node = star;
 	    (yyval.list)->next = (yyvsp[0].list);
 	}
-#line 3285 "cod.tab.c"
+#line 3155 "cod.tab.c"
     break;
 
   case 143: /* pointer: STAR pointer  */
@@ -3294,7 +3164,7 @@ yyparse (void)
 	    (yyval.list)->node = star;
 	    (yyval.list)->next = (yyvsp[0].list);
 	}
-#line 3298 "cod.tab.c"
+#line 3168 "cod.tab.c"
     break;
 
   case 144: /* pointer: STAR type_qualifier_list pointer  */
@@ -3313,7 +3183,7 @@ yyparse (void)
 	    (yyval.list)->node = star;
 	    (yyval.list)->next = (yyvsp[-1].list);
 	}
-#line 3317 "cod.tab.c"
+#line 3187 "cod.tab.c"
     break;
 
   case 145: /* pointer: AT  */
@@ -3329,7 +3199,7 @@ yyparse (void)
 	    (yyval.list)->node = star;
 	    (yyval.list)->next = NULL;
 	}
-#line 3333 "cod.tab.c"
+#line 3203 "cod.tab.c"
     break;
 
   case 146: /* pointer: AT type_qualifier_list  */
@@ -3345,7 +3215,7 @@ yyparse (void)
 	    (yyval.list)->node = star;
 	    (yyval.list)->next = (yyvsp[0].list);
 	}
-#line 3349 "cod.tab.c"
+#line 3219 "cod.tab.c"
     break;
 
   case 147: /* pointer: AT pointer  */
@@ -3361,7 +3231,7 @@ yyparse (void)
 	    (yyval.list)->node = star;
 	    (yyval.list)->next = (yyvsp[0].list);
 	}
-#line 3365 "cod.tab.c"
+#line 3235 "cod.tab.c"
     break;
 
   case 148: /* pointer: AT type_qualifier_list pointer  */
@@ -3383,7 +3253,7 @@ yyparse (void)
 	    (yyval.list)->node = star;
 	    (yyval.list)->next = (yyvsp[-1].list);
 	}
-#line 3387 "cod.tab.c"
+#line 3257 "cod.tab.c"
     break;
 
   case 149: /* type_qualifier_list: type_qualifier  */
@@ -3393,7 +3263,7 @@ yyparse (void)
 	    (yyval.list)->node = (yyvsp[0].reference);
 	    (yyval.list)->next = NULL;
 	}
-#line 3397 "cod.tab.c"
+#line 3267 "cod.tab.c"
     break;
 
   case 150: /* type_qualifier_list: type_qualifier_list type_qualifier  */
@@ -3408,7 +3278,7 @@ yyparse (void)
 	    tmp->next->next = NULL;
 	    (yyval.list) = (yyvsp[-1].list);
 	}
-#line 3412 "cod.tab.c"
+#line 3282 "cod.tab.c"
     break;
 
   case 152: /* parameter_type_list: parameter_list COMMA DOTDOTDOT  */
@@ -3425,7 +3295,7 @@ yyparse (void)
 	    id->node.declaration.id = strdup("...");
 	    (yyval.list) = (yyvsp[-2].list);
 	}
-#line 3429 "cod.tab.c"
+#line 3299 "cod.tab.c"
     break;
 
   case 153: /* parameter_list: parameter_declaration  */
@@ -3435,7 +3305,7 @@ yyparse (void)
 		(yyval.list)->node = (yyvsp[0].reference);
 		(yyval.list)->next = NULL;
 	}
-#line 3439 "cod.tab.c"
+#line 3309 "cod.tab.c"
     break;
 
   case 154: /* parameter_list: parameter_list COMMA parameter_declaration  */
@@ -3450,7 +3320,7 @@ yyparse (void)
 	    tmp->next->next = NULL;
 	    (yyval.list) = (yyvsp[-2].list);
 	}
-#line 3454 "cod.tab.c"
+#line 3324 "cod.tab.c"
     break;
 
   case 155: /* parameter_declaration: declaration_specifiers  */
@@ -3464,7 +3334,7 @@ yyparse (void)
 	    (yyval.reference)->node.declaration.params = NULL;
 	    (yyval.reference)->node.declaration.type_spec = (yyvsp[0].list);
 	}
-#line 3468 "cod.tab.c"
+#line 3338 "cod.tab.c"
     break;
 
   case 156: /* parameter_declaration: declaration_specifiers declarator  */
@@ -3506,7 +3376,7 @@ yyparse (void)
 		    printf("unexpected node in parameter_declaration");
 		}
 	}
-#line 3510 "cod.tab.c"
+#line 3380 "cod.tab.c"
     break;
 
   case 158: /* type_name: specifier_qualifier_list abstract_declarator  */
@@ -3519,7 +3389,7 @@ yyparse (void)
 	    tmp->next = (yyvsp[0].list);
 	    (yyval.list) = (yyvsp[-1].list);
 	}
-#line 3523 "cod.tab.c"
+#line 3393 "cod.tab.c"
     break;
 
   case 160: /* initializer: LCURLY initializer_list RCURLY  */
@@ -3528,7 +3398,7 @@ yyparse (void)
 	    (yyval.reference) = cod_new_initializer_list();
 	    (yyval.reference)->node.initializer_list.initializers = (yyvsp[-1].list);
 	}
-#line 3532 "cod.tab.c"
+#line 3402 "cod.tab.c"
     break;
 
   case 161: /* initializer: LCURLY initializer_list COMMA RCURLY  */
@@ -3537,13 +3407,13 @@ yyparse (void)
 	    (yyval.reference) = cod_new_initializer_list();
 	    (yyval.reference)->node.initializer_list.initializers = (yyvsp[-2].list);
 	}
-#line 3541 "cod.tab.c"
+#line 3411 "cod.tab.c"
     break;
 
   case 162: /* initializer: assignment_expression  */
 #line 1579 "cod.y"
                                 { (yyval.reference) = (yyvsp[0].reference);}
-#line 3547 "cod.tab.c"
+#line 3417 "cod.tab.c"
     break;
 
   case 163: /* initializer_list: designation initializer  */
@@ -3556,7 +3426,7 @@ yyparse (void)
 	    (yyval.list)->node = initializer;
 	    (yyval.list)->next = NULL;
 	}
-#line 3560 "cod.tab.c"
+#line 3430 "cod.tab.c"
     break;
 
   case 164: /* initializer_list: initializer  */
@@ -3569,7 +3439,7 @@ yyparse (void)
 	    (yyval.list)->node = initializer;
 	    (yyval.list)->next = NULL;
 	}
-#line 3573 "cod.tab.c"
+#line 3443 "cod.tab.c"
     break;
 
   case 165: /* initializer_list: initializer_list COMMA designation initializer  */
@@ -3587,7 +3457,7 @@ yyparse (void)
 	    tmp->next->next = NULL;
 	    (yyval.list) = (yyvsp[-3].list);
 	}
-#line 3591 "cod.tab.c"
+#line 3461 "cod.tab.c"
     break;
 
   case 166: /* initializer_list: initializer_list COMMA initializer  */
@@ -3605,13 +3475,13 @@ yyparse (void)
 	    tmp->next->next = NULL;
 	    (yyval.list) = (yyvsp[-2].list);
 	}
-#line 3609 "cod.tab.c"
+#line 3479 "cod.tab.c"
     break;
 
   case 167: /* designation: designator_list ASSIGN  */
 #line 1630 "cod.y"
         { (yyval.list) = (yyvsp[-1].list);}
-#line 3615 "cod.tab.c"
+#line 3485 "cod.tab.c"
     break;
 
   case 168: /* designator_list: designator  */
@@ -3621,7 +3491,7 @@ yyparse (void)
 		(yyval.list)->node = (yyvsp[0].reference);
 		(yyval.list)->next = NULL;
 	}
-#line 3625 "cod.tab.c"
+#line 3495 "cod.tab.c"
     break;
 
   case 169: /* designator_list: designator_list designator  */
@@ -3636,7 +3506,7 @@ yyparse (void)
 	    tmp->next->next = NULL;
 	    (yyval.list) = (yyvsp[-1].list);
 	}
-#line 3640 "cod.tab.c"
+#line 3510 "cod.tab.c"
     break;
 
   case 170: /* designator: LBRACKET constant_expression RBRACKET  */
@@ -3646,7 +3516,7 @@ yyparse (void)
 	    (yyval.reference)->node.designator.expression = (yyvsp[-1].reference);
 	    (yyval.reference)->node.designator.id = NULL;
 	}
-#line 3650 "cod.tab.c"
+#line 3520 "cod.tab.c"
     break;
 
   case 171: /* designator: DOT identifier_ref  */
@@ -3656,7 +3526,7 @@ yyparse (void)
 	    (yyval.reference)->node.designator.expression = NULL;
 	    (yyval.reference)->node.designator.id = (yyvsp[0].info).string;
 	}
-#line 3660 "cod.tab.c"
+#line 3530 "cod.tab.c"
     break;
 
   case 172: /* decls_stmts_list: statement  */
@@ -3667,7 +3537,7 @@ yyparse (void)
 	    tmp->next = NULL;
 	    (yyval.list) = tmp;
 	}
-#line 3671 "cod.tab.c"
+#line 3541 "cod.tab.c"
     break;
 
   case 173: /* decls_stmts_list: declaration  */
@@ -3675,7 +3545,7 @@ yyparse (void)
                        {
 	    (yyval.list) = (yyvsp[0].list);
 	   }
-#line 3679 "cod.tab.c"
+#line 3549 "cod.tab.c"
     break;
 
   case 174: /* decls_stmts_list: error SEMI  */
@@ -3683,7 +3553,7 @@ yyparse (void)
                      {
 	      (yyval.list) = NULL;
 	  }
-#line 3687 "cod.tab.c"
+#line 3557 "cod.tab.c"
     break;
 
   case 175: /* decls_stmts_list: decls_stmts_list statement  */
@@ -3694,7 +3564,7 @@ yyparse (void)
 	    tmp->next = NULL;
 	    (yyval.list) = cod_append_list((yyvsp[-1].list), tmp);
 	}
-#line 3698 "cod.tab.c"
+#line 3568 "cod.tab.c"
     break;
 
   case 176: /* decls_stmts_list: decls_stmts_list declaration  */
@@ -3702,7 +3572,7 @@ yyparse (void)
                                        {
 	    (yyval.list) = cod_append_list((yyvsp[-1].list), (yyvsp[0].list));
 	}
-#line 3706 "cod.tab.c"
+#line 3576 "cod.tab.c"
     break;
 
   case 183: /* labeled_statement: identifier_ref COLON statement  */
@@ -3712,7 +3582,7 @@ yyparse (void)
 	    (yyval.reference)->node.label_statement.name =  (yyvsp[-2].info).string;
 	    (yyval.reference)->node.label_statement.statement = (yyvsp[0].reference);
 	}
-#line 3716 "cod.tab.c"
+#line 3586 "cod.tab.c"
     break;
 
   case 184: /* compound_statement: LCURLY RCURLY  */
@@ -3720,7 +3590,7 @@ yyparse (void)
                       {
 	    (yyval.reference) = cod_new_compound_statement();
 	}
-#line 3724 "cod.tab.c"
+#line 3594 "cod.tab.c"
     break;
 
   case 185: /* compound_statement: LCURLY decls_stmts_list RCURLY  */
@@ -3731,13 +3601,13 @@ yyparse (void)
 	    (yyval.reference)->node.compound_statement.decls = (yyvsp[-1].list);
 	    cod_remove_defined_types(yycontext, count);
 	}
-#line 3735 "cod.tab.c"
+#line 3605 "cod.tab.c"
     break;
 
   case 186: /* declaration_list: declaration  */
 #line 1720 "cod.y"
                     { (yyval.list) = (yyvsp[0].list); }
-#line 3741 "cod.tab.c"
+#line 3611 "cod.tab.c"
     break;
 
   case 187: /* declaration_list: declaration_list declaration  */
@@ -3754,7 +3624,7 @@ yyparse (void)
 		(yyval.list) = (yyvsp[-1].list);
 	    }
 	}
-#line 3758 "cod.tab.c"
+#line 3628 "cod.tab.c"
     break;
 
   case 188: /* jump_statement: RETURN_TOKEN expression SEMI  */
@@ -3764,7 +3634,7 @@ yyparse (void)
 	    (yyval.reference)->node.return_statement.expression = (yyvsp[-1].reference);
 	    (yyval.reference)->node.return_statement.lx_srcpos = (yyvsp[-2].info).lx_srcpos;
 	}
-#line 3768 "cod.tab.c"
+#line 3638 "cod.tab.c"
     break;
 
   case 189: /* jump_statement: RETURN_TOKEN SEMI  */
@@ -3774,7 +3644,7 @@ yyparse (void)
 	    (yyval.reference)->node.return_statement.expression = NULL;
 	    (yyval.reference)->node.return_statement.lx_srcpos = (yyvsp[-1].info).lx_srcpos;
 	}
-#line 3778 "cod.tab.c"
+#line 3648 "cod.tab.c"
     break;
 
   case 190: /* jump_statement: CONTINUE SEMI  */
@@ -3785,7 +3655,7 @@ yyparse (void)
 	    (yyval.reference)->node.jump_statement.goto_target = NULL;
 	    (yyval.reference)->node.jump_statement.lx_srcpos = (yyvsp[-1].info).lx_srcpos;
 	}
-#line 3789 "cod.tab.c"
+#line 3659 "cod.tab.c"
     break;
 
   case 191: /* jump_statement: BREAK SEMI  */
@@ -3796,7 +3666,7 @@ yyparse (void)
 	    (yyval.reference)->node.jump_statement.goto_target = NULL;
 	    (yyval.reference)->node.jump_statement.lx_srcpos = (yyvsp[-1].info).lx_srcpos;
 	}
-#line 3800 "cod.tab.c"
+#line 3670 "cod.tab.c"
     break;
 
   case 192: /* jump_statement: GOTO identifier_ref SEMI  */
@@ -3807,7 +3677,7 @@ yyparse (void)
 	    (yyval.reference)->node.jump_statement.goto_target = (yyvsp[-1].info).string;
 	    (yyval.reference)->node.jump_statement.lx_srcpos = (yyvsp[-2].info).lx_srcpos;
 	}
-#line 3811 "cod.tab.c"
+#line 3681 "cod.tab.c"
     break;
 
   case 193: /* expression_statement: SEMI  */
@@ -3815,7 +3685,7 @@ yyparse (void)
              {
 	    (yyval.reference) = NULL;
 	}
-#line 3819 "cod.tab.c"
+#line 3689 "cod.tab.c"
     break;
 
   case 194: /* expression_statement: expression SEMI  */
@@ -3824,7 +3694,7 @@ yyparse (void)
 	    (yyval.reference) = cod_new_expression_statement();
 	    (yyval.reference)->node.expression_statement.expression = (yyvsp[-1].reference);
 	}
-#line 3828 "cod.tab.c"
+#line 3698 "cod.tab.c"
     break;
 
   case 195: /* selection_statement: IF LPAREN expression RPAREN statement  */
@@ -3836,7 +3706,7 @@ yyparse (void)
 	    (yyval.reference)->node.selection_statement.then_part = (yyvsp[0].reference);
 	    (yyval.reference)->node.selection_statement.else_part = NULL;
 	}
-#line 3840 "cod.tab.c"
+#line 3710 "cod.tab.c"
     break;
 
   case 196: /* selection_statement: IF LPAREN expression RPAREN statement ELSE statement  */
@@ -3848,7 +3718,7 @@ yyparse (void)
 	    (yyval.reference)->node.selection_statement.then_part = (yyvsp[-2].reference);
 	    (yyval.reference)->node.selection_statement.else_part = (yyvsp[0].reference);
 	}
-#line 3852 "cod.tab.c"
+#line 3722 "cod.tab.c"
     break;
 
   case 197: /* iteration_statement: FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement  */
@@ -3861,7 +3731,7 @@ yyparse (void)
 	    (yyval.reference)->node.iteration_statement.iter_expr = (yyvsp[-2].reference);
 	    (yyval.reference)->node.iteration_statement.statement = (yyvsp[0].reference);
 	}
-#line 3865 "cod.tab.c"
+#line 3735 "cod.tab.c"
     break;
 
   case 198: /* iteration_statement: WHILE LPAREN expression RPAREN statement  */
@@ -3874,7 +3744,7 @@ yyparse (void)
 	    (yyval.reference)->node.iteration_statement.iter_expr = NULL;
 	    (yyval.reference)->node.iteration_statement.statement = (yyvsp[0].reference);
 	}
-#line 3878 "cod.tab.c"
+#line 3748 "cod.tab.c"
     break;
 
   case 199: /* iteration_statement: DO statement WHILE LPAREN expression RPAREN SEMI  */
@@ -3888,13 +3758,13 @@ yyparse (void)
 	    (yyval.reference)->node.iteration_statement.iter_expr = NULL;
 	    (yyval.reference)->node.iteration_statement.statement = (yyvsp[-5].reference);
 	}
-#line 3892 "cod.tab.c"
+#line 3762 "cod.tab.c"
     break;
 
   case 200: /* expression_opt: %empty  */
 #line 1841 "cod.y"
         { (yyval.reference) = NULL; }
-#line 3898 "cod.tab.c"
+#line 3768 "cod.tab.c"
     break;
 
   case 202: /* constant: integer_constant  */
@@ -3905,7 +3775,7 @@ yyparse (void)
 	    (yyval.reference)->node.constant.const_val = (yyvsp[0].info).string;
 	    (yyval.reference)->node.constant.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	}
-#line 3909 "cod.tab.c"
+#line 3779 "cod.tab.c"
     break;
 
   case 203: /* constant: floating_constant  */
@@ -3916,7 +3786,7 @@ yyparse (void)
 	    (yyval.reference)->node.constant.const_val = (yyvsp[0].info).string;
 	    (yyval.reference)->node.constant.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	}
-#line 3920 "cod.tab.c"
+#line 3790 "cod.tab.c"
     break;
 
   case 204: /* constant: string_constant  */
@@ -3927,7 +3797,7 @@ yyparse (void)
 	    (yyval.reference)->node.constant.const_val = (yyvsp[0].info).string;
 	    (yyval.reference)->node.constant.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	}
-#line 3931 "cod.tab.c"
+#line 3801 "cod.tab.c"
     break;
 
   case 205: /* constant: character_constant  */
@@ -3938,7 +3808,7 @@ yyparse (void)
 	    (yyval.reference)->node.constant.const_val = (yyvsp[0].info).string;
 	    (yyval.reference)->node.constant.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	}
-#line 3942 "cod.tab.c"
+#line 3812 "cod.tab.c"
     break;
 
   case 206: /* constant: enumeration_constant  */
@@ -3949,11 +3819,11 @@ yyparse (void)
 	    (yyval.reference)->node.constant.const_val = (yyvsp[0].info).string;
 	    (yyval.reference)->node.constant.lx_srcpos = (yyvsp[0].info).lx_srcpos;
 	}
-#line 3953 "cod.tab.c"
+#line 3823 "cod.tab.c"
     break;
 
 
-#line 3957 "cod.tab.c"
+#line 3827 "cod.tab.c"
 
       default: break;
     }
@@ -8715,7 +8585,7 @@ space_to_underscore(char *str){
     while(*str != '\0'){
 	if(isspace(*str))
 	    *str = '_';
-	    str++;
+	str++;
     }
 }
 
@@ -9000,7 +8870,7 @@ evaluate_constant_return_expr(cod_parse_context context, sm_ref expr, int *free_
 	    *free_result = 1;
 	} else {
 	    /* we get an integer result */
-	    intptr_t left_val = 0, right_val = 0, value;
+	    intptr_t left_val = 0, right_val = 0, value = 0;
 	    char str_val[40];
 	    if (expr->node.operator.left)
 		left_val = get_constant_long_value(context, left);
@@ -9079,7 +8949,7 @@ evaluate_constant_return_expr(cod_parse_context context, sm_ref expr, int *free_
 	    }
 	    ret = cod_new_constant();
 	    ret->node.constant.token = integer_constant;
-	    sprintf(str_val, "%Id", value);
+	    sprintf(str_val, "%zd", value);
 	    ret->node.constant.const_val = strdup(str_val);
 	    *free_result = 1;
 	}
diff --git a/cod/pregen_source/Windows/cod.tab.h b/cod/pregen_source/Windows/cod.tab.h
index 9dfb351295..f291f75d49 100644
--- a/cod/pregen_source/Windows/cod.tab.h
+++ b/cod/pregen_source/Windows/cod.tab.h
@@ -1,14 +1,14 @@
-/* A Bison parser, made by GNU Bison 2.3.  */
+/* A Bison parser, made by GNU Bison 3.8.2.  */
 
-/* Skeleton interface for Bison's Yacc-like parsers in C
+/* Bison interface for Yacc-like parsers in C
 
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
-   Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
+   Inc.
 
-   This program is free software; you can redistribute it and/or modify
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -16,9 +16,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -33,200 +31,140 @@
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
-/* Tokens.  */
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
+
+#ifndef YY_YY_COD_TAB_H_INCLUDED
+# define YY_YY_COD_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token kinds.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     ARROW = 258,
-     LPAREN = 259,
-     RPAREN = 260,
-     LCURLY = 261,
-     RCURLY = 262,
-     COLON = 263,
-     QUESTION = 264,
-     LBRACKET = 265,
-     RBRACKET = 266,
-     DOT = 267,
-     STAR = 268,
-     AT = 269,
-     SLASH = 270,
-     MODULUS = 271,
-     PLUS = 272,
-     MINUS = 273,
-     TILDE = 274,
-     LEQ = 275,
-     LT = 276,
-     GEQ = 277,
-     GT = 278,
-     EQ = 279,
-     NEQ = 280,
-     LEFT_SHIFT = 281,
-     RIGHT_SHIFT = 282,
-     ASSIGN = 283,
-     MUL_ASSIGN = 284,
-     DIV_ASSIGN = 285,
-     MOD_ASSIGN = 286,
-     ADD_ASSIGN = 287,
-     SUB_ASSIGN = 288,
-     LEFT_ASSIGN = 289,
-     RIGHT_ASSIGN = 290,
-     AND_ASSIGN = 291,
-     XOR_ASSIGN = 292,
-     OR_ASSIGN = 293,
-     LOG_OR = 294,
-     LOG_AND = 295,
-     ARITH_OR = 296,
-     ARITH_AND = 297,
-     ARITH_XOR = 298,
-     INC_OP = 299,
-     DEC_OP = 300,
-     BANG = 301,
-     SEMI = 302,
-     IF = 303,
-     ELSE = 304,
-     FOR = 305,
-     DO = 306,
-     WHILE = 307,
-     CHAR = 308,
-     SHORT = 309,
-     INT = 310,
-     LONG = 311,
-     UNSIGNED = 312,
-     SIGNED = 313,
-     FLOAT = 314,
-     DOUBLE = 315,
-     VOID = 316,
-     STRING = 317,
-     STATIC = 318,
-     EXTERN_TOKEN = 319,
-     STRUCT = 320,
-     ENUM = 321,
-     UNION = 322,
-     CONST = 323,
-     SIZEOF = 324,
-     TYPEDEF = 325,
-     RETURN_TOKEN = 326,
-     CONTINUE = 327,
-     BREAK = 328,
-     GOTO = 329,
-     PRINT = 330,
-     COMMA = 331,
-     DOTDOTDOT = 332,
-     integer_constant = 333,
-     character_constant = 334,
-     string_constant = 335,
-     floating_constant = 336,
-     identifier_ref = 337,
-     type_identifier = 338,
-     enumeration_constant = 339
-   };
+  enum yytokentype
+  {
+    YYEMPTY = -2,
+    YYEOF = 0,                     /* "end of file"  */
+    YYerror = 256,                 /* error  */
+    YYUNDEF = 257,                 /* "invalid token"  */
+    ARROW = 258,                   /* ARROW  */
+    LPAREN = 259,                  /* LPAREN  */
+    RPAREN = 260,                  /* RPAREN  */
+    LCURLY = 261,                  /* LCURLY  */
+    RCURLY = 262,                  /* RCURLY  */
+    COLON = 263,                   /* COLON  */
+    QUESTION = 264,                /* QUESTION  */
+    LBRACKET = 265,                /* LBRACKET  */
+    RBRACKET = 266,                /* RBRACKET  */
+    DOT = 267,                     /* DOT  */
+    STAR = 268,                    /* STAR  */
+    AT = 269,                      /* AT  */
+    SLASH = 270,                   /* SLASH  */
+    MODULUS = 271,                 /* MODULUS  */
+    PLUS = 272,                    /* PLUS  */
+    MINUS = 273,                   /* MINUS  */
+    TILDE = 274,                   /* TILDE  */
+    LEQ = 275,                     /* LEQ  */
+    LT = 276,                      /* LT  */
+    GEQ = 277,                     /* GEQ  */
+    GT = 278,                      /* GT  */
+    EQ = 279,                      /* EQ  */
+    NEQ = 280,                     /* NEQ  */
+    LEFT_SHIFT = 281,              /* LEFT_SHIFT  */
+    RIGHT_SHIFT = 282,             /* RIGHT_SHIFT  */
+    ASSIGN = 283,                  /* ASSIGN  */
+    MUL_ASSIGN = 284,              /* MUL_ASSIGN  */
+    DIV_ASSIGN = 285,              /* DIV_ASSIGN  */
+    MOD_ASSIGN = 286,              /* MOD_ASSIGN  */
+    ADD_ASSIGN = 287,              /* ADD_ASSIGN  */
+    SUB_ASSIGN = 288,              /* SUB_ASSIGN  */
+    LEFT_ASSIGN = 289,             /* LEFT_ASSIGN  */
+    RIGHT_ASSIGN = 290,            /* RIGHT_ASSIGN  */
+    AND_ASSIGN = 291,              /* AND_ASSIGN  */
+    XOR_ASSIGN = 292,              /* XOR_ASSIGN  */
+    OR_ASSIGN = 293,               /* OR_ASSIGN  */
+    LOG_OR = 294,                  /* LOG_OR  */
+    LOG_AND = 295,                 /* LOG_AND  */
+    ARITH_OR = 296,                /* ARITH_OR  */
+    ARITH_AND = 297,               /* ARITH_AND  */
+    ARITH_XOR = 298,               /* ARITH_XOR  */
+    INC_OP = 299,                  /* INC_OP  */
+    DEC_OP = 300,                  /* DEC_OP  */
+    BANG = 301,                    /* BANG  */
+    SEMI = 302,                    /* SEMI  */
+    IF = 303,                      /* IF  */
+    ELSE = 304,                    /* ELSE  */
+    FOR = 305,                     /* FOR  */
+    DO = 306,                      /* DO  */
+    WHILE = 307,                   /* WHILE  */
+    CHAR = 308,                    /* CHAR  */
+    SHORT = 309,                   /* SHORT  */
+    INT = 310,                     /* INT  */
+    LONG = 311,                    /* LONG  */
+    UNSIGNED = 312,                /* UNSIGNED  */
+    SIGNED = 313,                  /* SIGNED  */
+    FLOAT = 314,                   /* FLOAT  */
+    DOUBLE = 315,                  /* DOUBLE  */
+    VOID = 316,                    /* VOID  */
+    STRING = 317,                  /* STRING  */
+    STATIC = 318,                  /* STATIC  */
+    EXTERN_TOKEN = 319,            /* EXTERN_TOKEN  */
+    STRUCT = 320,                  /* STRUCT  */
+    ENUM = 321,                    /* ENUM  */
+    UNION = 322,                   /* UNION  */
+    CONST = 323,                   /* CONST  */
+    SIZEOF = 324,                  /* SIZEOF  */
+    TYPEDEF = 325,                 /* TYPEDEF  */
+    RETURN_TOKEN = 326,            /* RETURN_TOKEN  */
+    CONTINUE = 327,                /* CONTINUE  */
+    BREAK = 328,                   /* BREAK  */
+    GOTO = 329,                    /* GOTO  */
+    PRINT = 330,                   /* PRINT  */
+    COMMA = 331,                   /* COMMA  */
+    DOTDOTDOT = 332,               /* DOTDOTDOT  */
+    integer_constant = 333,        /* integer_constant  */
+    character_constant = 334,      /* character_constant  */
+    string_constant = 335,         /* string_constant  */
+    floating_constant = 336,       /* floating_constant  */
+    identifier_ref = 337,          /* identifier_ref  */
+    type_identifier = 338,         /* type_identifier  */
+    enumeration_constant = 339     /* enumeration_constant  */
+  };
+  typedef enum yytokentype yytoken_kind_t;
 #endif
-/* Tokens.  */
-#define ARROW 258
-#define LPAREN 259
-#define RPAREN 260
-#define LCURLY 261
-#define RCURLY 262
-#define COLON 263
-#define QUESTION 264
-#define LBRACKET 265
-#define RBRACKET 266
-#define DOT 267
-#define STAR 268
-#define AT 269
-#define SLASH 270
-#define MODULUS 271
-#define PLUS 272
-#define MINUS 273
-#define TILDE 274
-#define LEQ 275
-#define LT 276
-#define GEQ 277
-#define GT 278
-#define EQ 279
-#define NEQ 280
-#define LEFT_SHIFT 281
-#define RIGHT_SHIFT 282
-#define ASSIGN 283
-#define MUL_ASSIGN 284
-#define DIV_ASSIGN 285
-#define MOD_ASSIGN 286
-#define ADD_ASSIGN 287
-#define SUB_ASSIGN 288
-#define LEFT_ASSIGN 289
-#define RIGHT_ASSIGN 290
-#define AND_ASSIGN 291
-#define XOR_ASSIGN 292
-#define OR_ASSIGN 293
-#define LOG_OR 294
-#define LOG_AND 295
-#define ARITH_OR 296
-#define ARITH_AND 297
-#define ARITH_XOR 298
-#define INC_OP 299
-#define DEC_OP 300
-#define BANG 301
-#define SEMI 302
-#define IF 303
-#define ELSE 304
-#define FOR 305
-#define DO 306
-#define WHILE 307
-#define CHAR 308
-#define SHORT 309
-#define INT 310
-#define LONG 311
-#define UNSIGNED 312
-#define SIGNED 313
-#define FLOAT 314
-#define DOUBLE 315
-#define VOID 316
-#define STRING 317
-#define STATIC 318
-#define EXTERN_TOKEN 319
-#define STRUCT 320
-#define ENUM 321
-#define UNION 322
-#define CONST 323
-#define SIZEOF 324
-#define TYPEDEF 325
-#define RETURN_TOKEN 326
-#define CONTINUE 327
-#define BREAK 328
-#define GOTO 329
-#define PRINT 330
-#define COMMA 331
-#define DOTDOTDOT 332
-#define integer_constant 333
-#define character_constant 334
-#define string_constant 335
-#define floating_constant 336
-#define identifier_ref 337
-#define type_identifier 338
-#define enumeration_constant 339
-
-
-
 
+/* Value type.  */
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef union YYSTYPE
-#line 187 "cod/cod.y"
+union YYSTYPE
 {
+#line 201 "cod.y"
+
     lx_info info;
     sm_ref reference;
     operator_t operator;
     sm_list list;
     char *string;
-}
-/* Line 1529 of yacc.c.  */
-#line 225 "/Users/eisen/prog/ffs/build/cod.tab.h"
-	YYSTYPE;
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
+
+#line 156 "cod.tab.h"
+
+};
+typedef union YYSTYPE YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
 #endif
 
+
 extern YYSTYPE yylval;
 
+
+int yyparse (void);
+
+
+#endif /* !YY_YY_COD_TAB_H_INCLUDED  */
diff --git a/cod/pregen_source/Windows/cod.y b/cod/pregen_source/Windows/cod.y
index 264b112904..3d99807dcb 100644
--- a/cod/pregen_source/Windows/cod.y
+++ b/cod/pregen_source/Windows/cod.y
@@ -6447,7 +6447,7 @@ space_to_underscore(char *str){
     while(*str != '\0'){
 	if(isspace(*str))
 	    *str = '_';
-	    str++;
+	str++;
     }
 }
 
@@ -6732,7 +6732,7 @@ evaluate_constant_return_expr(cod_parse_context context, sm_ref expr, int *free_
 	    *free_result = 1;
 	} else {
 	    /* we get an integer result */
-	    intptr_t left_val = 0, right_val = 0, value;
+	    intptr_t left_val = 0, right_val = 0, value = 0;
 	    char str_val[40];
 	    if (expr->node.operator.left)
 		left_val = get_constant_long_value(context, left);
@@ -6811,7 +6811,7 @@ evaluate_constant_return_expr(cod_parse_context context, sm_ref expr, int *free_
 	    }
 	    ret = cod_new_constant();
 	    ret->node.constant.token = integer_constant;
-	    sprintf(str_val, "%Id", value);
+	    sprintf(str_val, "%zd", value);
 	    ret->node.constant.const_val = strdup(str_val);
 	    *free_result = 1;
 	}
diff --git a/cod/pregen_source/Windows/lex.yy.c b/cod/pregen_source/Windows/lex.yy.c
index 100cc2fc18..0daf24e1f1 100644
--- a/cod/pregen_source/Windows/lex.yy.c
+++ b/cod/pregen_source/Windows/lex.yy.c
@@ -2728,70 +2728,9 @@ yywrap YY_PROTO(( void ))
 }
 
 
-#ifndef input
 /* flex, not lex */
 void yy_delete_buffer YY_PROTO((YY_BUFFER_STATE b));
 
-#ifdef WINNT
-/* old Windows code for MKS Toolkit version of flex */
-
-static void 
-terminate_string_parse()
-{
-    yyrestart(NULL);
-}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-static char* current_input_string;
-
-int my_yy_input(buf,result,max_size) {
-
-      if (current_input_string == NULL) 
-      {
-           
-           result = 0;
-      }
-      else
-           if (max_size < strlen(current_input_string)) 
-	   {
-	        memcpy((void*)buf, current_input_string, max_size);
-		current_input_string += max_size;
-		result = max_size;
-	   } else {
-	        int n = strlen(current_input_string);
-		memcpy((void*)buf, current_input_string, n+1);
-		current_input_string = NULL;
-		result = n;
-	   }
-      	  
-/*      printf("my_yy_input buf[%s],result[%d]\n",buf,result);*/
-      return result;
-}
-
-static void
-setup_for_string_parse(string, defined_types, enum_constants)
-const char *string;
-char **defined_types;
-char **enum_constants;
-{
-    type_count = defined_type_count;
-    types = defined_types;
-    enums = enum_constants;
-
-    current_input_string = string;
-    lex_offset = 1;
-    line_count = 1;
-}
-#else
 
 static YY_BUFFER_STATE bb = NULL;
 
@@ -2824,6 +2763,4 @@ terminate_string_parse()
 	}
 }
 
-#endif
-#endif
 
diff --git a/cod/standard.c b/cod/standard.c
index 2735741153..df9c7145dd 100644
--- a/cod/standard.c
+++ b/cod/standard.c
@@ -199,6 +199,10 @@ typedef struct timeval {
     long tv_usec;
 } timeval;
 #endif
+typedef struct timezone {
+    int tz_minuteswest;     /* minutes west of Greenwich */
+    int tz_dsttime;         /* type of DST correction */
+} timezone;
 
 int gettimeofday(struct timeval* tp, struct timezone* tzp)
 {
@@ -464,7 +468,7 @@ cod_add_standard_elements(cod_parse_context context)
 }
 #endif /* LINUX_KERNEL_MODULE */
 
-#if NO_DYNAMIC_LINKING
+#if defined(NO_DYNAMIC_LINKING) && !defined(_MSC_VER)
 #define sym(x) (void*)(intptr_t)x
 #else
 #define sym(x) (void*)0
diff --git a/cod/tests/CMakeLists.txt b/cod/tests/CMakeLists.txt
index 7da5c38893..2ade40f9da 100644
--- a/cod/tests/CMakeLists.txt
+++ b/cod/tests/CMakeLists.txt
@@ -15,7 +15,10 @@ foreach (TEST ${TESTS} )
     TARGET_LINK_LIBRARIES(${TEST} ${ATL_LIBRARIES} )
     ADD_TEST(NAME ${TEST} COMMAND ${TEST})
 endforeach()
-SET_SOURCE_FILES_PROPERTIES(general.c PROPERTIES COMPILE_FLAGS -O0)
+
+if (NOT CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
+   SET_SOURCE_FILES_PROPERTIES(general.c PROPERTIES COMPILE_FLAGS -O0)
+endif()
 
 set_tests_properties (t2
   PROPERTIES PASS_REGULAR_EXPRESSION "Expect -> .values are is 5, 3.14159, hello!.
diff --git a/cod/tests/general.ops b/cod/tests/general.ops
index a3a2d588f7..5f5570fedf 100644
--- a/cod/tests/general.ops
+++ b/cod/tests/general.ops
@@ -906,6 +906,7 @@ EOF
 	    $cnt = $cnt + 3;
 	}
     }
+    print COUT "    (void) rand1_p;\n    (void) rand2_p;\n";
     foreach $dr_type (split(' ', "f d c s i l uc us u ul")) {
         $rand_type = $rand_types{$dr_type};
         $c_type = $c_types{$dr_type};
diff --git a/cod/tests/t1.c b/cod/tests/t1.c
index 194d005822..8307f6a369 100644
--- a/cod/tests/t1.c
+++ b/cod/tests/t1.c
@@ -223,7 +223,7 @@ main(int argc, char**argv)
 	str.j = 4;
 	str.k = 10;
 	str.l = 3;
-	long tmp = func(EC_param1 param);
+	(void) func(EC_param1 param);
 	assert(func(EC_param1 param) == 90);
 	cod_exec_context_free(ec);
 	cod_code_free(gen_code);
diff --git a/ffs/ffs.c b/ffs/ffs.c
index 2bc61274c8..4b1f0e85f6 100755
--- a/ffs/ffs.c
+++ b/ffs/ffs.c
@@ -1563,6 +1563,8 @@ add_to_tmp_buffer(FFSBuffer buf, size_t size)
 }
 
 #if SIZEOF_LONG != 8
+#ifndef WORDS_BIGENDIAN
+
 static int words_bigendian = -1;
 
 static int
@@ -1577,7 +1579,6 @@ set_bigendian () {
   words_bigendian = (u.c[sizeof (long) - 1] == 1);
   return words_bigendian;
 }
-#ifndef WORDS_BIGENDIAN
 #define WORDS_BIGENDIAN ((words_bigendian == -1) ? set_bigendian() : words_bigendian)
 #endif
 #endif
diff --git a/ffs/ffs.h.in b/ffs/ffs.h.in
index 3708464633..21640793cc 100644
--- a/ffs/ffs.h.in
+++ b/ffs/ffs.h.in
@@ -51,13 +51,13 @@ typedef struct _FFSTypeHandle *FFSTypeHandle;
 typedef struct _FFSIndexItem *FFSIndexItem;
 
 #define create_FFSContext() create_FFSContext_FM(NULL)
-extern FFS_DECLSPEC FFSContext create_FFSContext_FM(FMContext fmc);
+extern FFSContext create_FFSContext_FM(FMContext fmc);
 
-extern FFS_DECLSPEC FFSBuffer create_FFSBuffer();
-extern FFS_DECLSPEC FFSBuffer create_fixed_FFSBuffer(char *buffer, size_t size);
-extern FFS_DECLSPEC void free_FFSBuffer(FFSBuffer buf);
+extern FFSBuffer create_FFSBuffer();
+extern FFSBuffer create_fixed_FFSBuffer(char *buffer, size_t size);
+extern void free_FFSBuffer(FFSBuffer buf);
 
-extern FFS_DECLSPEC char *
+extern char *
 FFSencode(FFSBuffer b, FMFormat ioformat, void *data, size_t *buf_size);
 
 typedef struct FFSEncodeVec {
@@ -65,133 +65,133 @@ typedef struct FFSEncodeVec {
     @UIO_SIZE_T_TYPE@ iov_len;
 } *FFSEncodeVector;
 
-extern FFS_DECLSPEC FFSEncodeVector
+extern FFSEncodeVector
 FFSencode_vector(FFSBuffer b, FMFormat fmformat, void *data);
 
-extern FFS_DECLSPEC char *
+extern char *
 FFSencode_no_leaf_copy(FFSBuffer b, FMFormat fmformat, void *data, size_t *buf_size);
 
-extern FFS_DECLSPEC int FFSdecode_in_place_possible(FFSTypeHandle);
+extern int FFSdecode_in_place_possible(FFSTypeHandle);
 
-extern FFS_DECLSPEC FFSTypeHandle FFSTypeHandle_from_encode(FFSContext c, char *b);
+extern FFSTypeHandle FFSTypeHandle_from_encode(FFSContext c, char *b);
 
-extern FFS_DECLSPEC FFSTypeHandle FFSTypeHandle_by_index(FFSContext c, int index);
+extern FFSTypeHandle FFSTypeHandle_by_index(FFSContext c, int index);
 
-extern FFS_DECLSPEC char * FFSTypeHandle_name(FFSTypeHandle f);
+extern char * FFSTypeHandle_name(FFSTypeHandle f);
 
-extern FFS_DECLSPEC void
+extern void
 establish_conversion(FFSContext c, FFSTypeHandle f,
 			   FMStructDescList struct_list);
 
-extern FFS_DECLSPEC int
+extern int
 FFShas_conversion(FFSTypeHandle format);
 
-extern FFS_DECLSPEC size_t
+extern size_t
 FFS_est_decode_length(FFSContext context, char *encoded, size_t record_length);
 
-extern FFS_DECLSPEC int
+extern int
 FFSdecode_in_place(FFSContext context, char *encode, void **dest_ptr);
 
-extern FFS_DECLSPEC int
+extern int
 FFSdecode_to_buffer(FFSContext context, char *encode, void *dest);
 
-extern FFS_DECLSPEC int
+extern int
 FFSdecode(FFSContext context, char *encode, char *dest);
 
-extern FFS_DECLSPEC FFSTypeHandle
+extern FFSTypeHandle
 FFSset_fixed_target(FFSContext c, FMStructDescList struct_list);
 
-extern FFS_DECLSPEC FFSTypeHandle
+extern FFSTypeHandle
 FFS_target_from_encode(FFSContext c, char *data);
 
-extern FFS_DECLSPEC FMFormat 
+extern FMFormat 
 FMFormat_of_original(FFSTypeHandle h);
 
-extern FFS_DECLSPEC FFSEncodeVector
+extern FFSEncodeVector
 copy_all_to_FFSBuffer(FFSBuffer buf, FFSEncodeVector vec);
 
-extern FFS_DECLSPEC FFSEncodeVector
+extern FFSEncodeVector
 copy_vector_to_FFSBuffer(FFSBuffer buf, FFSEncodeVector vec);
 
-extern FFS_DECLSPEC FMContext
+extern FMContext
 FMContext_from_FFS(FFSContext c);
 
-extern FFS_DECLSPEC void
+extern void
 free_FFSContext(FFSContext c);
 
-extern FFS_DECLSPEC FMStructDescList
+extern FMStructDescList
 get_localized_formats(FMFormat f);
 
 /*  file interface follows*/
 
-extern FFS_DECLSPEC FFSFile
+extern FFSFile
 open_FFSfile(const char *path, const char *flags);
 
-extern FFS_DECLSPEC FFSFile
+extern FFSFile
 open_FFSfd(void *fd, const char *flags);
 
-extern FFS_DECLSPEC void
+extern void
 close_FFSfile(FFSFile file);
 
-extern FFS_DECLSPEC void
+extern void
 free_FFSfile(FFSFile file);
 
-extern FFS_DECLSPEC int
+extern int
 write_FFSfile(FFSFile f, FMFormat format, void *data);
 
-extern FFS_DECLSPEC int
+extern int
 write_FFSfile_attrs(FFSFile f, FMFormat format, void *data, attr_list attrs);
 
-extern FFS_DECLSPEC int
+extern int
 write_comment_FFSfile(FFSFile f, const char *comment);
 
-extern FFS_DECLSPEC size_t
+extern size_t
 FFSfile_next_decode_length(FFSFile iofile);
 
 typedef enum {
     FFSerror=1, FFSend=2, FFSdata=4, FFSformat=8, FFScomment=16, FFSindex=32
 } FFSRecordType;
 
-extern FFS_DECLSPEC void
+extern void
 FFSset_visible(FFSFile ffsfile, int bitmap);
 
-extern FFS_DECLSPEC FFSRecordType
+extern FFSRecordType
 FFSnext_record_type(FFSFile ffsfile);
 
-extern FFS_DECLSPEC size_t
+extern size_t
 FFSnext_data_length(FFSFile file);
 
-extern FFS_DECLSPEC FFSTypeHandle
+extern FFSTypeHandle
 FFSnext_type_handle(FFSFile ffsfile);
 
-extern FFS_DECLSPEC char *
+extern char *
 FFSread_comment(FFSFile ffsfile);
 
-extern FFS_DECLSPEC int
+extern int
 FFSread(FFSFile ffsfile, void *dest);
 
-extern FFS_DECLSPEC int
+extern int
 FFSread_attr(FFSFile file, void *dest, attr_list *attr);
 
-extern FFS_DECLSPEC int
+extern int
 FFSread_to_buffer(FFSFile file, FFSBuffer b,  void **dest);
 
-extern FFS_DECLSPEC attr_list
+extern attr_list
 FFSattrs_from_last_read(FFSFile file);
 
-extern FFS_DECLSPEC FFSTypeHandle
+extern FFSTypeHandle
 FFSread_format(FFSFile ffsfile);
 
-extern FFS_DECLSPEC FFSIndexItem
+extern FFSIndexItem
 FFSread_index(FFSFile ffsfile);
 
-extern FFS_DECLSPEC FFSContext
+extern FFSContext
 FFSContext_of_file(FFSFile f);
 
-extern FFS_DECLSPEC FMContext
+extern FMContext
 FMContext_of_file(FFSFile f);
 
-extern FFS_DECLSPEC int
+extern int
 FFSseek(FFSFile file, int data_item);
 
 #if defined(__cplusplus) || defined(c_plusplus)
diff --git a/ffs/tests/context_test.c b/ffs/tests/context_test.c
index 19af8d4442..fe178133c3 100755
--- a/ffs/tests/context_test.c
+++ b/ffs/tests/context_test.c
@@ -4,6 +4,9 @@
 #ifdef STDC_HEADERS
 #include <stdlib.h>
 #endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
 #include <stdio.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
diff --git a/fm/fm.h b/fm/fm.h
index cba86f288a..aa8df30fa7 100755
--- a/fm/fm.h
+++ b/fm/fm.h
@@ -9,18 +9,12 @@ extern "C" {
 
 typedef struct _FMContextStruct *FMContext;
 
-#if defined(_MSC_VER) && !defined(FFS_SRC)
-#define FFS_DECLSPEC    __declspec(dllimport)
-#else
-#define FFS_DECLSPEC
-#endif
-
-extern FFS_DECLSPEC FMContext create_FMcontext();
-extern FFS_DECLSPEC FMContext create_local_FMcontext();
-extern FFS_DECLSPEC void free_FMcontext(FMContext c);
-extern FFS_DECLSPEC void add_ref_FMcontext(FMContext c);
-extern FFS_DECLSPEC void FMcontext_allow_self_formats(FMContext fmc);
-extern FFS_DECLSPEC int
+extern FMContext create_FMcontext();
+extern FMContext create_local_FMcontext();
+extern void free_FMcontext(FMContext c);
+extern void add_ref_FMcontext(FMContext c);
+extern void FMcontext_allow_self_formats(FMContext fmc);
+extern int
 FMcontext_get_format_server_identifier(FMContext fmc);
 
 
@@ -85,19 +79,19 @@ typedef enum {
 typedef struct _FMFormatBody *FMFormatBodyPtr;
 typedef FMFormatBodyPtr FMFormat;
 
-extern FFS_DECLSPEC char *
+extern char *
 get_server_rep_FMformat(FMFormat ioformat, int *rep_length);
 
-extern FFS_DECLSPEC char *
+extern char *
 get_server_ID_FMformat(FMFormat ioformat, int *id_length);
 
-extern FFS_DECLSPEC FMContext
+extern FMContext
 FMContext_from_FMformat(FMFormat ioformat);
 
-extern FFS_DECLSPEC int
+extern int
 get_rep_len_format_ID(void *format_ID);
 
-extern FFS_DECLSPEC void
+extern void
 set_array_order_FMContext(FMContext iofile, int column_major);
 
 FMFormat
@@ -109,23 +103,23 @@ FMformat_index(FMFormat f);
 FMFormat
 FMformat_by_index(FMContext c, int index);
 
-extern FFS_DECLSPEC FMFormat
+extern FMFormat
 load_external_format_FMcontext(FMContext iocontext, char *server_id,
 				     int id_size, char *server_rep);
 
-extern FFS_DECLSPEC void
+extern void
 add_opt_info_FMformat(FMFormat format, int typ, int len, void *block);
 
-extern FFS_DECLSPEC FMFormat
+extern FMFormat
 FMregister_simple_format(FMContext context, char *format_name, FMFieldList field_list, int struct_size);
 
-extern FFS_DECLSPEC FMFormat
+extern FMFormat
 register_data_format(FMContext context, FMStructDescList struct_list);
 
-extern FFS_DECLSPEC FMFormat
+extern FMFormat
 FMregister_data_format(FMContext context, FMStructDescList struct_list);
 
-extern FFS_DECLSPEC void free_FMfield_list(FMFieldList list);
+extern void free_FMfield_list(FMFieldList list);
 
 /*!
  * lookup the FMFormat associated with a particular FMStructDescList
@@ -148,7 +142,7 @@ extern FFS_DECLSPEC void free_FMfield_list(FMFieldList list);
  * address.   Normally if you use static format lists, the addresses will 
  * be unique. 
  */
-extern FFS_DECLSPEC FMFormat
+extern FMFormat
 FMlookup_format(FMContext context, FMStructDescList struct_list);
 
 typedef enum {Format_Less, Format_Greater, Format_Equal, 
@@ -161,125 +155,125 @@ typedef struct compat_formats {
     char *xform_code;
 } *FMcompat_formats;
 
-extern FFS_DECLSPEC FMcompat_formats
+extern FMcompat_formats
 FMget_compat_formats(FMFormat ioformat);
 
-extern FFS_DECLSPEC char *
+extern char *
 name_of_FMformat(FMFormat format);
 
-extern FFS_DECLSPEC FMStructDescList
+extern FMStructDescList
 format_list_of_FMFormat(FMFormat format);
 
-extern FFS_DECLSPEC void
+extern void
 FMlocalize_structs(FMStructDescList list);
 
-extern FFS_DECLSPEC char *
+extern char *
 global_name_of_FMFormat(FMFormat format);
 
-extern FFS_DECLSPEC FMFieldList
+extern FMFieldList
 copy_field_list(FMFieldList list);
 
-extern FFS_DECLSPEC FMStructDescList
+extern FMStructDescList
 FMcopy_struct_list(FMStructDescList list);
 
-extern FFS_DECLSPEC void
+extern void
 FMfree_struct_list(FMStructDescList list);
 
-extern FFS_DECLSPEC int
+extern int
 FMstruct_size_field_list(FMFieldList list, int pointer_size);
 
-extern FFS_DECLSPEC FMStructDescList
+extern FMStructDescList
 FMlocalize_formats(FMStructDescList list);
 
-extern FFS_DECLSPEC int 
+extern int 
 count_FMfield(FMFieldList list);
 
-extern FFS_DECLSPEC void print_server_ID(unsigned char *ID);
-extern FFS_DECLSPEC void print_format_ID(FMFormat ioformat);
-extern FFS_DECLSPEC void fprint_server_ID(void * file,unsigned char *ID);
+extern void print_server_ID(unsigned char *ID);
+extern void print_format_ID(FMFormat ioformat);
+extern void fprint_server_ID(void * file,unsigned char *ID);
 
-extern FFS_DECLSPEC int FMformatID_len(char *buffer);
+extern int FMformatID_len(char *buffer);
 
-extern FFS_DECLSPEC int
+extern int
 FMdump_data(FMFormat format, void *data, int character_limit);
 
-extern FFS_DECLSPEC int
+extern int
 FMdump_encoded_data(FMFormat format, void *data, int character_limit);
 
-extern FFS_DECLSPEC void
+extern void
 FMdump_XML(FMFormat format, void *data, int encoded);
 
-extern FFS_DECLSPEC void
+extern void
 FMdump_encoded_XML(FMContext c, void *data, int character_limit);
 
-extern FFS_DECLSPEC int
+extern int
 FMfdump_data(void *file, FMFormat format, void *data, int character_limit);
 
-extern FFS_DECLSPEC int
+extern int
 FMfdump_encoded_data(void *file, FMFormat format, void *data, int character_limit);
 
-extern FFS_DECLSPEC void
+extern void
 FMfdump_XML(void *file, FMFormat format, void *data, int encoded);
 
-extern FFS_DECLSPEC void
+extern void
 FMfdump_encoded_XML(void *file, FMContext c, void *data, int character_limit);
 
-extern FFS_DECLSPEC char*
+extern char*
 FMunencoded_to_XML_string(FMContext fmcontext, FMFormat format, void *data);
 
-extern FFS_DECLSPEC void
+extern void
 FMfree_var_rec_elements(FMFormat format, void *data);
 
-extern FFS_DECLSPEC char *FMbase_type(const char *field_type);
+extern char *FMbase_type(const char *field_type);
 
 #define XML_OPT_INFO 0x584D4C20
 #define COMPAT_OPT_INFO 0x45564F4C
 #define COMPAT_OPT_INFO_FMFILE 0x45564F4D
 
 typedef struct _FMgetFieldStruct *FMFieldPtr;
-extern FFS_DECLSPEC FMFieldPtr get_FMfieldPtrFromList(FMFieldList field_list, 
+extern FMFieldPtr get_FMfieldPtrFromList(FMFieldList field_list, 
 					 const char *fieldname);
 
-extern FFS_DECLSPEC void *
+extern void *
 get_FMfieldAddr_by_name(FMFieldList field_list, const char *fieldname, void *data);
-extern FFS_DECLSPEC void *
+extern void *
 get_FMPtrField_by_name(FMFieldList field_list, const char *fieldname, void *data, int encode);
-extern FFS_DECLSPEC int
+extern int
 set_FMPtrField_by_name(FMFieldList field_list, const char *fieldname, void *data, void *ptr_value);
-extern FFS_DECLSPEC int
+extern int
 get_FMfieldInt_by_name(FMFieldList field_list, const char *fieldname, void *data);
-extern FFS_DECLSPEC size_t
+extern size_t
 get_FMfieldLong_by_name(FMFieldList field_list, const char *fieldname, void *data);
 
-extern FFS_DECLSPEC void * FMheader_skip(FMContext c, void *data);
-extern FFS_DECLSPEC char *get_FMstring_base(FMFieldPtr iofield, void *data, void *string_base);
-extern FFS_DECLSPEC void *get_FMFieldAddr(FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC void *get_FMaddr (FMFieldPtr iofield, void *data, void *string_base, int encode);
-extern FFS_DECLSPEC void *put_FMaddr (FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC float get_FMfloat(FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC double get_FMdouble(FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC short get_FMshort(FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC int get_FMint(FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC size_t get_FMlong(FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC void get_FMlong8(FMFieldPtr iofield, void *data, unsigned long *low_long, long *high_long);
+extern void * FMheader_skip(FMContext c, void *data);
+extern char *get_FMstring_base(FMFieldPtr iofield, void *data, void *string_base);
+extern void *get_FMFieldAddr(FMFieldPtr iofield, void *data);
+extern void *get_FMaddr (FMFieldPtr iofield, void *data, void *string_base, int encode);
+extern void *put_FMaddr (FMFieldPtr iofield, void *data);
+extern float get_FMfloat(FMFieldPtr iofield, void *data);
+extern double get_FMdouble(FMFieldPtr iofield, void *data);
+extern short get_FMshort(FMFieldPtr iofield, void *data);
+extern int get_FMint(FMFieldPtr iofield, void *data);
+extern size_t get_FMlong(FMFieldPtr iofield, void *data);
+extern void get_FMlong8(FMFieldPtr iofield, void *data, unsigned long *low_long, long *high_long);
 #if defined(SIZEOF_LONG_LONG)
 #if SIZEOF_LONG_LONG != 0
-extern FFS_DECLSPEC long long get_FMlong_long(FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC unsigned long long get_FMulong_long(FMFieldPtr iofield, void *data);
+extern long long get_FMlong_long(FMFieldPtr iofield, void *data);
+extern unsigned long long get_FMulong_long(FMFieldPtr iofield, void *data);
 #endif
 #endif
 #if defined(SIZEOF_LONG_DOUBLE)
 #if SIZEOF_LONG_DOUBLE != 0
-extern FFS_DECLSPEC long double get_FMlong_double(FMFieldPtr iofield, void *data);
+extern long double get_FMlong_double(FMFieldPtr iofield, void *data);
 #endif
 #endif
-extern FFS_DECLSPEC unsigned short get_FMushort(FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC unsigned int get_FMuint(FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC size_t get_FMulong(FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC int get_FMulong8(FMFieldPtr iofield, void *data, unsigned long *low_long, unsigned long *high_long);
-extern FFS_DECLSPEC char *get_FMstring(FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC char get_FMchar(FMFieldPtr iofield, void *data);
-extern FFS_DECLSPEC int get_FMenum(FMFieldPtr iofield, void *data);
+extern unsigned short get_FMushort(FMFieldPtr iofield, void *data);
+extern unsigned int get_FMuint(FMFieldPtr iofield, void *data);
+extern size_t get_FMulong(FMFieldPtr iofield, void *data);
+extern int get_FMulong8(FMFieldPtr iofield, void *data, unsigned long *low_long, unsigned long *high_long);
+extern char *get_FMstring(FMFieldPtr iofield, void *data);
+extern char get_FMchar(FMFieldPtr iofield, void *data);
+extern int get_FMenum(FMFieldPtr iofield, void *data);
 
 #if defined(__cplusplus) || defined(c_plusplus)
 }
diff --git a/fm/fm_dump.c b/fm/fm_dump.c
index 2c77715be3..8fd7e28d46 100644
--- a/fm/fm_dump.c
+++ b/fm/fm_dump.c
@@ -109,6 +109,7 @@ dump_output(dstate s, size_t length_estimate, char *format, ...)
 }
 
 #if SIZEOF_LONG != 8
+#ifndef WORDS_BIGENDIAN
 static int words_bigendian = -1;
 
 static int
@@ -123,7 +124,6 @@ set_bigendian () {
   words_bigendian = (u.c[sizeof (long) - 1] == 1);
   return words_bigendian;
 }
-#ifndef WORDS_BIGENDIAN
 #define WORDS_BIGENDIAN ((words_bigendian == -1) ? set_bigendian() : words_bigendian)
 #endif
 #endif
diff --git a/fm/fm_formats.c b/fm/fm_formats.c
index 83414a45a5..83ff1604cf 100755
--- a/fm/fm_formats.c
+++ b/fm/fm_formats.c
@@ -1982,7 +1982,7 @@ generate_format3_server_ID(server_ID_type *server_ID,
     ((version_3_format_ID *) server_ID->value)->rep_len = 
 	htons((short)(server_format_rep_length >> 2));   // Mod length by 4
     ((version_3_format_ID *) server_ID->value)->top_byte_rep_len = (unsigned char)
-	htons((short)(server_format_rep_length >> 18));  // Essentially, we capture the top 26 bytes of the server length
+	0xff & (server_format_rep_length >> 18);
     ((version_3_format_ID *) server_ID->value)->hash1 = htonl(hash1);
     ((version_3_format_ID *) server_ID->value)->hash2 = htonl(hash2);
 }
@@ -3953,11 +3953,12 @@ stringify_server_ID(unsigned char *ID, char *buffer, int len)
 	    break;
 	}
     case 2:{
-	version_2_format_ID *id2 = (version_2_format_ID*)ID;
+	version_3_format_ID *id3 = (version_3_format_ID*)ID;
 	if (len < 3+3+6+10+6+50) /* approx size */ return;
-	snprintf(buffer, len, "<ID ver=%d, unused %d, rep_len %d, hash1 %x, hash2 %x>\n",
-	       id2->version, id2->unused, ntohs(id2->rep_len) << 2,
-	       ntohl(id2->hash1), ntohl(id2->hash2));
+	int rep_len = get_rep_len_format_ID(ID);
+	snprintf(buffer, len, "<ID ver=%d, rep_len %d, hash1 %x, hash2 %x>\n",
+	       id3->version, rep_len,
+	       ntohl(id3->hash1), ntohl(id3->hash2));
 	    break;
 	}
     default:
@@ -4021,11 +4022,10 @@ get_rep_len_format_ID(void *format_ID)
 {
     switch (version_of_format_ID(format_ID)) {
     case 2:{
-	    version_2_format_ID *id2 = (version_2_format_ID *) format_ID;
-	    short tmp;
-	    memcpy(&tmp, &id2->rep_len, 2);
-		tmp = ntohs(tmp);
-	    return tmp << 2;
+	    version_3_format_ID *id3 = (version_3_format_ID *) format_ID;
+	    int rep_len = htons(id3->rep_len);
+	    rep_len += (id3->top_byte_rep_len << 16);
+	    return rep_len << 2;
 	}
     case 0:
     case 1:
diff --git a/fm/io_interface.h b/fm/io_interface.h
index e0f635bdec..d17200cfad 100644
--- a/fm/io_interface.h
+++ b/fm/io_interface.h
@@ -1,4 +1,4 @@
-#if defined(HAVE_WINDOWS_H) && !defined(NEED_IOVEC_DEFINE) && !defined(_STRUCT_IOVEC)
+#if defined(_MSC_VER) && !defined(_STRUCT_IOVEC)
 #define _STRUCT_IOVEC
 struct	iovec {
     const void *iov_base;
diff --git a/fm/nt_io.c b/fm/nt_io.c
index c0d047c808..d33155826e 100755
--- a/fm/nt_io.c
+++ b/fm/nt_io.c
@@ -82,7 +82,7 @@ char **result_p;
 	    (tmp != WSAEINTR)) {
 	    /* serious error */
 	    fprintf(stderr, "WINSOCK ERROR during receive, %i on socket %p\n",
-		    tmp, conn);
+		    (int)tmp, conn);
 	    return -1;
 	} else {
 		if (tmp == WSAECONNRESET)
@@ -110,7 +110,7 @@ char **result_p;
 
 		    /* serious error */
 		    fprintf(stderr, "WINSOCK ERROR during receive2, %i on socket %p\n",
-			    tmp, conn);
+			    (int) tmp, conn);
 		    return (length - left);
 		} else {
 			if (tmp == WSAECONNRESET)
@@ -141,10 +141,9 @@ char **result_p;
 
     while (left > 0) {
 	bResult = WriteFile((HANDLE) conn, (char *) buffer + length - left, 
-			    left, &iget, NULL);
+			    left, (unsigned long *)&iget, NULL);
 	if (!bResult) {
 	    DWORD tmp = GetLastError();
-	    if (errno_p) tmp = tmp;
 	    if ((tmp != WSAEWOULDBLOCK) &&
 		(tmp != WSAEINPROGRESS) &&
 		(tmp != WSAEINTR)) {
@@ -277,7 +276,7 @@ char **result_p;
 
     int i = 0;
     for (; i < icount; i++) {
-	if (nt_socket_read_func(conn, iov[i].iov_base, iov[i].iov_len,
+	if (nt_socket_read_func(conn, (void*)iov[i].iov_base, iov[i].iov_len,
 				errno_p, result_p) != iov[i].iov_len) {
 	    return i;
 	}
@@ -297,7 +296,7 @@ char **result_p;
 
     int i = 0;
     for (; i < icount; i++) {
-	if (nt_file_read_func(conn, iov[i].iov_base, iov[i].iov_len, errno_p,
+	if (nt_file_read_func(conn, (void*)iov[i].iov_base, iov[i].iov_len, errno_p,
 			      result_p) != iov[i].iov_len) {
 	    return i;
 	}
@@ -316,7 +315,7 @@ char** result_p;
 
     int i = 0;
     for (; i < icount; i++) {
-	if (nt_file_write_func(conn, iov[i].iov_base, iov[i].iov_len, errno_p,
+	if (nt_file_write_func(conn, (void*)iov[i].iov_base, iov[i].iov_len, errno_p,
 	    result_p) != iov[i].iov_len) {
 	    return i;
 	}
diff --git a/fm/tests/scale_test.c b/fm/tests/scale_test.c
index 5e06f7f20b..a3190d8c9c 100644
--- a/fm/tests/scale_test.c
+++ b/fm/tests/scale_test.c
@@ -41,7 +41,7 @@ main(int argc, char **argv)
 {
 
     FMStructDescRec str_list[5];
-    struct timespec start, stop;
+    struct timespec start = {0,0}, stop = {0,0};
     
     FMContext context;
     int field_count = 20000;
diff --git a/scripts/ci/cmake/windows-common.cmake b/scripts/ci/cmake/windows-common.cmake
index 1b227e5395..d5ab37c858 100644
--- a/scripts/ci/cmake/windows-common.cmake
+++ b/scripts/ci/cmake/windows-common.cmake
@@ -4,4 +4,9 @@ string(APPEND dashboard_cache "
 ")
 
 list(APPEND CTEST_UPDATE_NOTES_FILES "${CMAKE_CURRENT_LIST_FILE}")
+
+# the two lines below shouldn't be necessary, but something wrong with vcpkg maybe
+set(ENV{dill_DIR} "${CMAKE_CURRENT_LIST_DIR}/../../../../dill/install/lib/cmake/dill")
+set(ENV{atl_DIR} "${CMAKE_CURRENT_LIST_DIR}/../../../../atl/install/lib/cmake/atl")
+
 include(${CMAKE_CURRENT_LIST_DIR}/common.cmake)
diff --git a/scripts/ci/cmake/windows2022-vs2022-msvc-static.cmake b/scripts/ci/cmake/windows2022-vs2022-msvc-static.cmake
new file mode 100644
index 0000000000..cdb9e59d4e
--- /dev/null
+++ b/scripts/ci/cmake/windows2022-vs2022-msvc-static.cmake
@@ -0,0 +1,8 @@
+# Client maintainer: chuck.atkins@kitware.com
+
+set(CTEST_CMAKE_GENERATOR "Visual Studio 17 2022")
+set(CTEST_CMAKE_GENERATOR_PLATFORM x64)
+set(BUILD_SHARED_LIBS off)
+
+list(APPEND CTEST_UPDATE_NOTES_FILES "${CMAKE_CURRENT_LIST_FILE}")
+include(${CMAKE_CURRENT_LIST_DIR}/windows-common.cmake)

From be72fcb5569180dddb77aea57d6c8ca7721e09d8 Mon Sep 17 00:00:00 2001
From: EVPath Upstream <robot@adios2>
Date: Mon, 15 Apr 2024 15:30:41 -0500
Subject: [PATCH 3/5] EVPath 2024-04-15 (241c72a6)

Code extracted from:

    https://github.com/GTkorvo/EVPath.git

at commit 241c72a64619d84fc20ae4fdaf0c26ddda5b220e (master).

Upstream Shortlog
-----------------
---
 CMakeLists.txt                 |  10 +--
 cmenet.c                       |   2 +-
 cmepoll.c                      | 128 +++++++--------------------------
 cmib.c                         |  71 +++++-------------
 cmmulticast.c                  |   2 +-
 cmselect.c                     |   2 +-
 cmsockets.c                    |   3 +-
 cmudp.c                        |   2 +-
 dfg_tests/auto_tree_test.c     |   7 ++
 dfg_tests/fail_chain_test.c    |   7 ++
 dfg_tests/self_reconfig_test.c |   7 ++
 dfg_tests/tree_test.c          |   7 ++
 ev_dfg.c                       |   5 +-
 evp.c                          |   6 +-
 mtests/cmconn.c                |   3 +-
 mtests/cmping.c                |   1 +
 mtests/cmtest.c                |   1 +
 response.c                     |   2 +-
 rtests/evtest.c                |   1 +
 rtests/extract_test.c          |   1 +
 rtests/remote_terminal_test.c  |   1 +
 tests/evtest.c                 |   1 +
 tests/extract_test.c           |   2 +-
 23 files changed, 96 insertions(+), 176 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 003f31325f..384160c512 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -376,7 +376,7 @@ if (MSVC)
     set(EVPATH_USE_ZPL_ENET FALSE)
 endif()
 if(NOT (DEFINED EVPATH_USE_ZPL_ENET))
-  option(EVPATH_USE_ZPL_ENET "Build the enet transport" "ON")
+  option(EVPATH_USE_ZPL_ENET "Build the zplenet transport" "OFF")
 endif()
 if(EVPATH_USE_ZPL_ENET)
   set(RUN_ZPL_ENET_TESTS TRUE)
@@ -447,7 +447,7 @@ else()
   option(EVPATH_USE_LIBFABRIC "Build the libfabric transport"
     ${LIBFABRIC_FOUND})
 endif()
-if(LIBFABRIC_FOUND) 
+if(LIBFABRIC_FOUND AND NOT EVPATH_NO_RDMA) 
   if(EVPATH_TRANSPORT_MODULES)
     add_library(cmfabric MODULE cmfabric.c ip_config.c)
     set_target_properties(cmfabric PROPERTIES
@@ -485,7 +485,7 @@ else()
   option(EVPATH_USE_IBVERBS "Build the libfabric transport" ${IBVERBS_FOUND})
 endif()
 set(HAVE_IBVERBS ${IBVERBS_FOUND})
-if(IBVERBS_FOUND)
+if(IBVERBS_FOUND AND NOT EVPATH_NO_RDMA)
   if(BUILD_TESTING)
     if(NOT CMAKE_CROSSCOMPILING)
       message(STATUS "Check MEMLOCK rlimit for IB tests")
@@ -548,7 +548,7 @@ if(IBVERBS_FOUND)
     find_package(NNTI)
     option(EVPATH_USE_NNTI "Build the nnti transport" ${NNTI_FOUND})
   endif()
-  if(NNTI_FOUND)
+  if(NNTI_FOUND AND NOT EVPATH_NO_RDMA)
     if(CercsArch STREQUAL "ppc64")
       set(RUN_NNTI_TESTS FALSE)
     endif()
@@ -571,7 +571,7 @@ if(IBVERBS_FOUND)
     endif()
   endif()
 else()
-  set(EVPATH_USE_NNTI FALSE "Build the nnti transport" FORCE)
+  set(EVPATH_USE_NNTI FALSE CACHE INTERNAL "Build the nnti transport" FORCE)
 endif()
 
 # Install extra find module dependencies
diff --git a/cmenet.c b/cmenet.c
index eeac56f3e5..b33989de52 100644
--- a/cmenet.c
+++ b/cmenet.c
@@ -1414,7 +1414,7 @@ int err;
  *  NT Sux.
  */
 
-int
+static int
 pipe(filedes)
 SOCKET filedes[2];
 {
diff --git a/cmepoll.c b/cmepoll.c
index b28fca2790..84d95470c9 100644
--- a/cmepoll.c
+++ b/cmepoll.c
@@ -114,10 +114,7 @@ static char*WSAerror_str(int err);
 #endif
 
 static void
-init_select_data(svc, sdp, cm)
-CMtrans_services svc;
-select_data_ptr *sdp;
-CManager cm;
+init_select_data(CMtrans_services svc, select_data_ptr *sdp, CManager cm)
 {
     select_data_ptr sd = malloc(sizeof(struct select_data));
     *sdp = sd;
@@ -157,9 +154,7 @@ typedef struct _periodic_task {
 } task_handle_s;
 
 static void
-free_epoll_data(svc, sdp)
-CMtrans_services svc;
-select_data_ptr *sdp;
+free_epoll_data(CMtrans_services svc, select_data_ptr *sdp)
 {
     periodic_task_handle tasks;
     select_data_ptr sd = *sdp;
@@ -184,10 +179,7 @@ select_data_ptr *sdp;
 	((tvp)->tv_usec cmp (uvp)->tv_usec))))
 
 static void
-set_soonest_timeout(timeout, task_list, now)
-struct timeval *timeout;
-periodic_task_handle task_list;
-struct timeval now;
+set_soonest_timeout(struct timeval *timeout, periodic_task_handle task_list, struct timeval now)
 {
     struct timeval this_delay;
     if (task_list == NULL) return;
@@ -210,10 +202,7 @@ struct timeval now;
 }
 
 static void
-increment_time(time, increment_sec, increment_usec)
-struct timeval *time;
-int increment_sec;
-int increment_usec;
+increment_time(struct timeval *time, int increment_sec, int increment_usec)
 {
     time->tv_usec += increment_usec;
     time->tv_sec += increment_sec;
@@ -227,11 +216,7 @@ static void
 shutdown_wake_mechanism(select_data_ptr sd);
 
 static void
-socket_select(svc, sd, timeout_sec, timeout_usec)
-CMtrans_services svc;
-select_data_ptr sd;
-int timeout_sec;
-int timeout_usec;
+socket_select(CMtrans_services svc, select_data_ptr sd, int timeout_sec, int timeout_usec)
 {
     int i, res;
     int fd;
@@ -475,13 +460,7 @@ int timeout_usec;
 }
 
 extern void
-libcmepoll_LTX_add_select(svc, sdp, fd, func, arg1, arg2)
-CMtrans_services svc;
-select_data_ptr *sdp;
-int fd;
-select_list_func func;
-void *arg1;
-void *arg2;
+libcmepoll_LTX_add_select(CMtrans_services svc, select_data_ptr *sdp, int fd, select_list_func func, void *arg1, void *arg2)
 {
     select_data_ptr sd = *((select_data_ptr *)sdp);
     struct epoll_event ep_event;
@@ -540,13 +519,7 @@ void *arg2;
 }
 
 extern void
-libcmepoll_LTX_write_select(svc, sdp, fd, func, arg1, arg2)
-CMtrans_services svc;
-select_data_ptr *sdp;
-int fd;
-select_list_func func;
-void *arg1;
-void *arg2;
+libcmepoll_LTX_write_select(CMtrans_services svc, select_data_ptr *sdp, int fd, select_list_func func, void *arg1, void *arg2)
 {
     select_data_ptr sd = *((select_data_ptr *)sdp);
     struct epoll_event ep_event;
@@ -616,15 +589,7 @@ void *arg2;
 }
 
 extern periodic_task_handle
-libcmepoll_LTX_add_periodic(svc, sdp, interval_sec, interval_usec,
-			     func, arg1, arg2)
-CMtrans_services svc;
-select_data_ptr *sdp;
-int interval_sec;
-int interval_usec;
-select_list_func func;
-void *arg1;
-void *arg2;
+libcmepoll_LTX_add_periodic(CMtrans_services svc, select_data_ptr *sdp, int interval_sec, int interval_usec, select_list_func func, void *arg1, void *arg2)
 {
     select_data_ptr sd = *((select_data_ptr *)sdp);
     periodic_task_handle handle = malloc(sizeof(struct _periodic_task));
@@ -671,15 +636,7 @@ void *arg2;
 
 
 extern periodic_task_handle
-libcmepoll_LTX_add_delayed_task(svc, sdp, delay_sec, delay_usec, 
-				 func, arg1, arg2)
-CMtrans_services svc;
-select_data_ptr *sdp;
-int delay_sec;
-int delay_usec;
-select_list_func func;
-void *arg1;
-void *arg2;
+libcmepoll_LTX_add_delayed_task(CMtrans_services svc, select_data_ptr *sdp, int delay_sec, int delay_usec, select_list_func func, void *arg1, void *arg2)
 {
     select_data_ptr sd = *((select_data_ptr *)sdp);
     periodic_task_handle handle = malloc(sizeof(struct _periodic_task));
@@ -725,9 +682,7 @@ void *arg2;
 }
 
 static int
-remove_periodic_task(sd, handle)
-select_data_ptr sd;
-periodic_task_handle handle;
+remove_periodic_task(select_data_ptr sd, periodic_task_handle handle)
 {
     periodic_task_handle list, last = NULL;
     list = sd->periodic_task_list;
@@ -765,10 +720,7 @@ periodic_task_handle handle;
 
 
 extern void
-libcmepoll_LTX_remove_periodic(svc, sdp, handle)
-CMtrans_services svc;
-select_data_ptr *sdp;
-periodic_task_handle handle;
+libcmepoll_LTX_remove_periodic(CMtrans_services svc, select_data_ptr *sdp, periodic_task_handle handle)
 {
     select_data_ptr sd = *((select_data_ptr *)sdp);
     if (sd == NULL) return;
@@ -778,10 +730,7 @@ periodic_task_handle handle;
 }
 
 extern void
-libcmepoll_LTX_remove_select(svc, sdp, fd)
-CMtrans_services svc;
-select_data_ptr *sdp;
-int fd;
+libcmepoll_LTX_remove_select(CMtrans_services svc, select_data_ptr *sdp, int fd)
 {
     select_data_ptr sd = *((select_data_ptr *)sdp);
 
@@ -812,8 +761,7 @@ int fd;
 }
 
 static void
-shutdown_wake_mechanism(sd)
-select_data_ptr sd;
+shutdown_wake_mechanism(select_data_ptr sd)
 {
     if (sd->wake_read_fd == -1) return;
     close(sd->wake_read_fd);
@@ -821,9 +769,7 @@ select_data_ptr sd;
     sd->wake_read_fd = sd->wake_write_fd = -1;
 }
 
-static void read_wake_fd(fd_as_ptr, junk)
-void *fd_as_ptr;
-void *junk;
+static void read_wake_fd(void *fd_as_ptr, void *junk)
 {
     char buffer;
     int fd = (int) (long)fd_as_ptr;
@@ -838,8 +784,7 @@ void *junk;
 
 #ifdef HAVE_WINDOWS_H
 static char*
-WSAerror_str(err)
-int err;
+WSAerror_str(int err)
 {
     switch(err) {
     case WSAEINTR: return "WSAEINTR";
@@ -900,9 +845,8 @@ int err;
  *  NT Sux.
  */
 
-int
-pipe(filedes)
-int filedes[2];
+static int
+pipe(int filedes[2])
 {
     
     int length;
@@ -990,9 +934,7 @@ int filedes[2];
 #endif
 
 static void
-setup_wake_mechanism(svc, sdp)
-CMtrans_services svc;
-select_data_ptr *sdp;
+setup_wake_mechanism(CMtrans_services svc, select_data_ptr *sdp)
 {
     int filedes[2];
 
@@ -1015,9 +957,7 @@ select_data_ptr *sdp;
 }
 
 extern void
-libcmepoll_LTX_wake_function(svc, sdp)
-CMtrans_services svc;
-select_data_ptr *sdp;
+libcmepoll_LTX_wake_function(CMtrans_services svc, select_data_ptr *sdp)
 {
     if (*sdp != NULL) {
 	wake_server_thread(*sdp);
@@ -1025,8 +965,7 @@ select_data_ptr *sdp;
 }
 
 static void
-wake_server_thread(sd)
-select_data_ptr sd;
+wake_server_thread(select_data_ptr sd)
 {
     static char buffer = 'W';  /* doesn't matter what we write */
     if (sd->wake_write_fd != -1) {
@@ -1041,9 +980,7 @@ select_data_ptr sd;
 }
 
 extern void
-libcmepoll_LTX_blocking_function(svc, client_data)
-CMtrans_services svc;
-void *client_data;
+libcmepoll_LTX_blocking_function(CMtrans_services svc, void *client_data)
 {
     select_data_ptr sd = *((select_data_ptr *)client_data);
     if (sd == NULL) {
@@ -1058,9 +995,7 @@ void *client_data;
 }
 
 extern void
-libcmepoll_LTX_polling_function(svc, client_data)
-CMtrans_services svc;
-void *client_data;
+libcmepoll_LTX_polling_function(CMtrans_services svc, void *client_data)
 {
     select_data_ptr sd = *((select_data_ptr *)client_data);
     if (sd == NULL) {
@@ -1075,10 +1010,7 @@ void *client_data;
 }
 
 extern void
-libcmepoll_LTX_select_initialize(svc, cm, client_data)
-CMtrans_services svc;
-CManager cm;
-void *client_data;
+libcmepoll_LTX_select_initialize(CMtrans_services svc, CManager cm, void *client_data)
 {
     if (*((select_data_ptr *)client_data) == NULL) {
 	init_select_data(svc, (select_data_ptr*)client_data, cm);
@@ -1086,10 +1018,7 @@ void *client_data;
 }
 
 extern void
-libcmepoll_LTX_select_shutdown(svc, cm, client_data)
-CMtrans_services svc;
-CManager cm;
-void *client_data;
+libcmepoll_LTX_select_shutdown(CMtrans_services svc, CManager cm, void *client_data)
 {
     select_data_ptr *sdp = client_data;
     select_data_ptr sd = *sdp;
@@ -1103,10 +1032,7 @@ void *client_data;
 }
 
 extern void
-libcmepoll_LTX_select_free(svc, cm, client_data)
-CMtrans_services svc;
-CManager cm;
-void *client_data;
+libcmepoll_LTX_select_free(CMtrans_services svc, CManager cm, void *client_data)
 {
     select_data_ptr *sdp = client_data;
     select_data_ptr sd = *sdp;
@@ -1119,9 +1045,7 @@ void *client_data;
 }
 
 extern void
-libcmepoll_LTX_select_stop(svc, client_data)
-CMtrans_services svc;
-void *client_data;
+libcmepoll_LTX_select_stop(CMtrans_services svc, void *client_data)
 {
     if (*((select_data_ptr *)client_data) != NULL) {
 	(*((select_data_ptr*)client_data))->closed = 1;
diff --git a/cmib.c b/cmib.c
index 6cfd7c828f..1a956cedb1 100644
--- a/cmib.c
+++ b/cmib.c
@@ -369,9 +369,7 @@ static inline uint16_t get_local_lid(struct ibv_context *context, int port)
 }
 
 static int
-check_host(hostname, sin_addr)
-	char *hostname;
-void *sin_addr;
+check_host(char *hostname,void *sin_addr)
 {
 	struct hostent *host_addr;
 	host_addr = gethostbyname(hostname);
@@ -393,8 +391,7 @@ void *sin_addr;
 }
 
 static ib_conn_data_ptr 
-create_ib_conn_data(svc)
-	CMtrans_services svc;
+create_ib_conn_data(CMtrans_services svc)
 {
 	ib_conn_data_ptr ib_conn_data = svc->malloc_func(sizeof(struct ib_connection_data));
 	memset(ib_conn_data, 0, sizeof(struct ib_connection_data));
@@ -946,9 +943,7 @@ CMIB_data_available(transport_entry trans, CMConnection conn)
  * Accept socket connection
  */
 static void
-ib_accept_conn(void_trans, void_conn_sock)
-	void *void_trans;
-void *void_conn_sock;
+ib_accept_conn(void *void_trans, void *void_conn_sock)
 {
 	transport_entry trans = (transport_entry) void_trans;
 	int conn_sock = (int) (long) void_conn_sock;
@@ -1106,9 +1101,7 @@ void *void_conn_sock;
 }
 
 extern void
-libcmib_LTX_shutdown_conn(svc, scd)
-	CMtrans_services svc;
-ib_conn_data_ptr scd;
+libcmib_LTX_shutdown_conn(CMtrans_services svc, ib_conn_data_ptr scd)
 {
 	svc->trace_out(scd->sd->cm, "CMIB shutdown_conn, removing select %d\n",
 	               scd->fd);
@@ -1141,14 +1134,7 @@ is_private_10(int IP)
 }
 
 static int
-initiate_conn(cm, svc, trans, attrs, ib_conn_data, conn_attr_list, no_more_redirect)
-	CManager cm;
-CMtrans_services svc;
-transport_entry trans;
-attr_list attrs;
-ib_conn_data_ptr ib_conn_data;
-attr_list conn_attr_list;
-int no_more_redirect;
+initiate_conn(CManager cm, CMtrans_services svc, transport_entry trans, attr_list attrs, ib_conn_data_ptr ib_conn_data, attr_list conn_attr_list, int no_more_redirect)
 {
 	int sock;
 
@@ -1413,11 +1399,7 @@ int no_more_redirect;
  * (name_str stores the machine name).
  */
 extern CMConnection
-libcmib_LTX_initiate_conn(cm, svc, trans, attrs)
-	CManager cm;
-CMtrans_services svc;
-transport_entry trans;
-attr_list attrs;
+libcmib_LTX_initiate_conn(CManager cm, CMtrans_services svc, transport_entry trans, attr_list attrs)
 {
 	ib_conn_data_ptr ib_conn_data = create_ib_conn_data(svc);
 	attr_list conn_attr_list = create_attr_list();
@@ -1447,11 +1429,7 @@ attr_list attrs;
  * same as ours and if the IP_PORT matches the one we are listening on.
  */
 extern int
-libcmib_LTX_self_check(cm, svc, trans, attrs)
-	CManager cm;
-CMtrans_services svc;
-transport_entry trans;
-attr_list attrs;
+libcmib_LTX_self_check(CManager cm, CMtrans_services svc, transport_entry trans, attr_list attrs)
 {
 
 	ib_client_data_ptr sd = trans->trans_data;
@@ -1499,12 +1477,9 @@ attr_list attrs;
 }
 
 extern int
-libcmib_LTX_connection_eq(cm, svc, trans, attrs, scd)
-	CManager cm;
-CMtrans_services svc;
-transport_entry trans;
-attr_list attrs;
-ib_conn_data_ptr scd;
+libcmib_LTX_connection_eq(CManager cm, CMtrans_services svc, 
+			  transport_entry trans, attr_list attrs,
+			  ib_conn_data_ptr scd)
 {
 
 	int int_port_num;
@@ -1548,11 +1523,8 @@ ib_conn_data_ptr scd;
  * Create an IP socket for connection from other CMs
  */
 extern attr_list
-libcmib_LTX_non_blocking_listen(cm, svc, trans, listen_info)
-	CManager cm;
-CMtrans_services svc;
-transport_entry trans;
-attr_list listen_info;
+libcmib_LTX_non_blocking_listen(CManager cm, CMtrans_services svc,
+				transport_entry trans, attr_list listen_info)
 {
 	ib_client_data_ptr sd = trans->trans_data;
 	unsigned int length;
@@ -1714,11 +1686,8 @@ struct iovec {
 #endif
 
 extern void
-libcmib_LTX_set_write_notify(trans, svc, scd, enable)
-	transport_entry trans;
-CMtrans_services svc;
-ib_conn_data_ptr scd;
-int enable;
+libcmib_LTX_set_write_notify(transport_entry trans, CMtrans_services svc,
+			     ib_conn_data_ptr scd, int enable)
 {
 	if (enable != 0) {
 		svc->fd_write_select(trans->cm, scd->fd, (select_list_func) trans->write_possible,
@@ -1910,12 +1879,8 @@ libcmib_LTX_writev_complete_notify_func(CMtrans_services svc,
 }
 
 extern int
-libcmib_LTX_writev_func(svc, scd, iovs, iovcnt, attrs)
-CMtrans_services svc;
-ib_conn_data_ptr scd;
-void *iovs;
-int iovcnt;
-attr_list attrs;
+libcmib_LTX_writev_func(CMtrans_services svc, ib_conn_data_ptr scd,
+			void *iovs, int iovcnt, attr_list attrs)
 {
     return libcmib_LTX_writev_complete_notify_func(svc, scd, iovs, iovcnt, 
 						   attrs, NULL, NULL);
@@ -1934,9 +1899,7 @@ free_ib_data(CManager cm, void *sdv)
 }
 
 extern void *
-libcmib_LTX_initialize(cm, svc)
-	CManager cm;
-CMtrans_services svc;
+libcmib_LTX_initialize(CManager cm, CMtrans_services svc)
 {
 	static int atom_init = 0;
 
diff --git a/cmmulticast.c b/cmmulticast.c
index 03acd641e7..3d0e1f0897 100644
--- a/cmmulticast.c
+++ b/cmmulticast.c
@@ -449,7 +449,7 @@ libcmmulticast_LTX_writev_func(CMtrans_services svc, mcast_conn_data_ptr mcd, st
 }
 
 #ifdef HAVE_WINDOWS_H
-int socket_global_init = 0;
+static int socket_global_init = 0;
 /* Winsock init stuff, ask for ver 1.1 */
 static WORD wVersionRequested = MAKEWORD(1, 1);
 static WSADATA wsaData;
diff --git a/cmselect.c b/cmselect.c
index baf9409df6..ab0ad46a19 100644
--- a/cmselect.c
+++ b/cmselect.c
@@ -879,7 +879,7 @@ int err;
  *  NT Sux.
  */
 
-int
+static int
 pipe(SOCKET *filedes)
 {
     
diff --git a/cmsockets.c b/cmsockets.c
index a4bfb79688..a054fd452d 100644
--- a/cmsockets.c
+++ b/cmsockets.c
@@ -457,7 +457,6 @@ initiate_conn(CManager cm, CMtrans_services svc, transport_entry trans, attr_lis
 	    int err = WSAGetLastError();
 	    if (err != WSAEWOULDBLOCK || err != WSAEINPROGRESS) {
 #endif
-		printf("Errno was %d\n", errno);
 		svc->trace_out(cm, "CMSocket connect FAILURE --> Connect() to IP %s failed", ip_str);
 		close(sock);
 #ifdef WSAEWOULDBLOCK
@@ -1135,7 +1134,7 @@ libcmsockets_LTX_NBwritev_func(CMtrans_services svc, socket_conn_data_ptr scd, v
     return init_bytes - left;
 }
 
-int socket_global_init = 0;
+static int socket_global_init = 0;
 
 #ifdef HAVE_WINDOWS_H
 /* Winsock init stuff, ask for ver 2.2 */
diff --git a/cmudp.c b/cmudp.c
index d865034dde..4c6815f2ad 100644
--- a/cmudp.c
+++ b/cmudp.c
@@ -646,7 +646,7 @@ libcmudp_LTX_writev_func(CMtrans_services svc, udp_conn_data_ptr ucd, struct iov
 }
 
 #ifdef HAVE_WINDOWS_H
-int socket_global_init = 0;
+static int socket_global_init = 0;
 /* Winsock init stuff, ask for ver 1.1 */
 static WORD wVersionRequested = MAKEWORD(1, 1);
 static WSADATA wsaData;
diff --git a/dfg_tests/auto_tree_test.c b/dfg_tests/auto_tree_test.c
index d4b1d781b6..97705efd4b 100644
--- a/dfg_tests/auto_tree_test.c
+++ b/dfg_tests/auto_tree_test.c
@@ -5,6 +5,7 @@
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <signal.h>
 #include <string.h>
 
 #include "cod.h"
@@ -71,6 +72,12 @@ be_test_master(int argc, char **argv)
 #ifdef HAVE_WINDOWS_H
     SetTimer(NULL, 5, 1000, (TIMERPROC) fail_and_die);
 #else
+    struct sigaction sigact;
+    sigact.sa_flags = 0;
+    sigact.sa_handler = fail_and_die;
+    sigemptyset(&sigact.sa_mask);
+    sigaddset(&sigact.sa_mask, SIGALRM);
+    sigaction(SIGALRM, &sigact, NULL);
     alarm(240);  /* reset time limit to 4 minutes */
 #endif
     if (argc == 1) {
diff --git a/dfg_tests/fail_chain_test.c b/dfg_tests/fail_chain_test.c
index a3673e6db4..e68cae7962 100755
--- a/dfg_tests/fail_chain_test.c
+++ b/dfg_tests/fail_chain_test.c
@@ -6,6 +6,7 @@
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <signal.h>
 #include "evpath.h"
 #include "ev_dfg.h"
 #include "test_support.h"
@@ -140,6 +141,12 @@ be_test_master(int argc, char **argv)
 #ifdef HAVE_WINDOWS_H
     SetTimer(NULL, 5, 1000, (TIMERPROC) fail_and_die);
 #else
+    struct sigaction sigact;
+    sigact.sa_flags = 0;
+    sigact.sa_handler = fail_and_die;
+    sigemptyset(&sigact.sa_mask);
+    sigaddset(&sigact.sa_mask, SIGALRM);
+    sigaction(SIGALRM, &sigact, NULL);
     alarm(240);  /* reset time limit to 4 minutes */
 #endif
     if (argc == 1) {
diff --git a/dfg_tests/self_reconfig_test.c b/dfg_tests/self_reconfig_test.c
index 4970d8d050..6484c79c2f 100644
--- a/dfg_tests/self_reconfig_test.c
+++ b/dfg_tests/self_reconfig_test.c
@@ -6,6 +6,7 @@
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <signal.h>
 #include "evpath.h"
 #include "ev_dfg.h"
 #include "test_support.h"
@@ -168,6 +169,12 @@ be_test_master(int argc, char **argv)
 #ifdef HAVE_WINDOWS_H
     SetTimer(NULL, 5, 1000, (TIMERPROC) fail_and_die);
 #else
+    struct sigaction sigact;
+    sigact.sa_flags = 0;
+    sigact.sa_handler = fail_and_die;
+    sigemptyset(&sigact.sa_mask);
+    sigaddset(&sigact.sa_mask, SIGALRM);
+    sigaction(SIGALRM, &sigact, NULL);
     alarm(240);  /* reset time limit to 4 minutes */
 #endif
     if (argc == 1) {
diff --git a/dfg_tests/tree_test.c b/dfg_tests/tree_test.c
index d157647986..5770de6eb4 100644
--- a/dfg_tests/tree_test.c
+++ b/dfg_tests/tree_test.c
@@ -6,6 +6,7 @@
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <signal.h>
 
 #include "ev_dfg.h"
 #include "test_support.h"
@@ -56,6 +57,12 @@ be_test_master(int argc, char **argv)
 #ifdef HAVE_WINDOWS_H
     SetTimer(NULL, 5, 1000, (TIMERPROC) fail_and_die);
 #else
+    struct sigaction sigact;
+    sigact.sa_flags = 0;
+    sigact.sa_handler = fail_and_die;
+    sigemptyset(&sigact.sa_mask);
+    sigaddset(&sigact.sa_mask, SIGALRM);
+    sigaction(SIGALRM, &sigact, NULL);
     alarm(300);
 #endif
     if (argc == 1) {
diff --git a/ev_dfg.c b/ev_dfg.c
index 3493e0a431..3720d401f8 100644
--- a/ev_dfg.c
+++ b/ev_dfg.c
@@ -1583,13 +1583,14 @@ INT_EVdfg_create(EVmaster master)
 extern char *INT_EVmaster_get_contact_list(EVmaster master)
 {
     attr_list contact_list = NULL;
-    atom_t CM_TRANSPORT = attr_atom_from_string("CM_TRANSPORT");
-    atom_t CM_ENET_CONN_TIMEOUT = attr_atom_from_string("CM_ENET_CONN_TIMEOUT");
     CManager cm = master->cm;
     char *tmp = NULL;
 
     /* use enet transport if available */
 #if defined(ENET_FOUND) || defined(ZPL_ENET_AVAILABLE)
+    atom_t CM_ENET_CONN_TIMEOUT = attr_atom_from_string("CM_ENET_CONN_TIMEOUT");
+    atom_t CM_TRANSPORT = attr_atom_from_string("CM_TRANSPORT");
+    (void) CM_TRANSPORT;
     attr_list listen_list = create_attr_list();
 #if defined(ENET_FOUND)
     add_string_attr(listen_list, CM_TRANSPORT, strdup("enet"));
diff --git a/evp.c b/evp.c
index f72ddb0cf8..d38ae3cc7c 100644
--- a/evp.c
+++ b/evp.c
@@ -3700,7 +3700,7 @@ INT_EVextract_stone_events(CManager cm, EVstone stone_id)
     stone_type stone;
     EVevent_list list = malloc(sizeof(list[0]));
 
-    list[0].length = -1;
+    list[0].length = (size_t)-1;
     stone = stone_struct(evp, stone_id);
     if (!stone) return NULL;
     list = extract_events_from_queue(cm, stone->queue, list);
@@ -3764,7 +3764,7 @@ extract_events_from_queue(CManager cm, queue_ptr que, EVevent_list list)
     first = que->queue_head;
     last = que->queue_tail;
                 
-    while (list[num_of_elements].length != -1) num_of_elements++;
+    while (list[num_of_elements].length != (size_t)-1) num_of_elements++;
     while(first != NULL && last != NULL) {
 	list = (EVevent_list) realloc (list, (num_of_elements + 2) * sizeof(list[0]));
 	current_entry = &list[num_of_elements];
@@ -3779,7 +3779,7 @@ extract_events_from_queue(CManager cm, queue_ptr que, EVevent_list list)
 	num_of_elements++;
 	first = first->next;
     }
-    list[num_of_elements].length = -1;
+    list[num_of_elements].length = (size_t)-1;
     return list;
 }
 
diff --git a/mtests/cmconn.c b/mtests/cmconn.c
index a2a3cafdd3..6b723b4fda 100644
--- a/mtests/cmconn.c
+++ b/mtests/cmconn.c
@@ -26,9 +26,8 @@
 #include <arpa/inet.h>
 #endif
 #include "evpath.h"
-#ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
-#endif
+
 #ifdef _MSC_VER
 #define drand48() (((double)rand())/((double)RAND_MAX))
 #define lrand48() rand()
diff --git a/mtests/cmping.c b/mtests/cmping.c
index 067eb11f76..59a0783054 100644
--- a/mtests/cmping.c
+++ b/mtests/cmping.c
@@ -18,6 +18,7 @@
 #define srand48(x)
 #define kill(x,y) TerminateProcess(OpenProcess(0,0,(DWORD)x),y)
 #else
+#include <sys/socket.h>
 #include <sys/wait.h>
 #include <arpa/inet.h>
 #endif
diff --git a/mtests/cmtest.c b/mtests/cmtest.c
index 0396443fee..3b2ef85810 100644
--- a/mtests/cmtest.c
+++ b/mtests/cmtest.c
@@ -18,6 +18,7 @@
 #define srand48(x)
 #define kill(x,y) TerminateProcess(OpenProcess(0, 0, (DWORD)x),y)
 #else
+#include <sys/socket.h>
 #include <sys/wait.h>
 #include <arpa/inet.h>
 #endif
diff --git a/response.c b/response.c
index fae5c44294..fad8f71cac 100644
--- a/response.c
+++ b/response.c
@@ -1974,7 +1974,7 @@ extern sm_ref
 cod_build_param_node(const char *id, sm_ref typ, int param_num);
 extern void
 cod_add_decl_to_parse_context(const char *name, sm_ref item, cod_parse_context context);
-extern FFS_DECLSPEC void
+extern void
 cod_add_param(const char *id, const char *typ, int param_num,
 	      cod_parse_context context);
 
diff --git a/rtests/evtest.c b/rtests/evtest.c
index cf1a2ac732..615fc7f903 100644
--- a/rtests/evtest.c
+++ b/rtests/evtest.c
@@ -20,6 +20,7 @@
 #define srand48(x)
 #define kill(x,y) TerminateProcess(OpenProcess(0,0,(DWORD)x),y)
 #else
+#include <sys/socket.h>
 #include <sys/wait.h>
 #include <arpa/inet.h>
 #endif
diff --git a/rtests/extract_test.c b/rtests/extract_test.c
index ed2677329b..47fe155248 100644
--- a/rtests/extract_test.c
+++ b/rtests/extract_test.c
@@ -19,6 +19,7 @@
 #define srand48(x)
 #define kill(x,y) TerminateProcess(OpenProcess(0, 0, (DWORD)x),y)
 #else
+#include <sys/socket.h>
 #include <arpa/inet.h>
 #include <sys/wait.h>
 #endif
diff --git a/rtests/remote_terminal_test.c b/rtests/remote_terminal_test.c
index 999bb626b4..8896145d1c 100644
--- a/rtests/remote_terminal_test.c
+++ b/rtests/remote_terminal_test.c
@@ -19,6 +19,7 @@
 #define srand48(x)
 #define kill(x,y) TerminateProcess(OpenProcess(0,0,(DWORD)x),y)
 #else
+#include <sys/socket.h>
 #include <arpa/inet.h>
 #include <sys/wait.h>
 #endif
diff --git a/tests/evtest.c b/tests/evtest.c
index b13102dbf8..59481adf78 100644
--- a/tests/evtest.c
+++ b/tests/evtest.c
@@ -18,6 +18,7 @@
 #define srand48(x)
 #define kill(x,y) TerminateProcess(OpenProcess(0,0,(DWORD)x),y)
 #else
+#include <sys/socket.h>
 #include <sys/wait.h>
 #include <arpa/inet.h>
 #endif
diff --git a/tests/extract_test.c b/tests/extract_test.c
index 5ef1816aed..90247c7abd 100644
--- a/tests/extract_test.c
+++ b/tests/extract_test.c
@@ -321,7 +321,7 @@ main(int argc, char **argv)
 	EVdrain_stone(cm, term1);
 	events = EVextract_stone_events(cm, term1);
 	count = 0;
-	while (events && (events[count].length != -1)) {
+	while (events && (events[count].length != (size_t)-1)) {
 	    EVsubmit_encoded(cm, term0, events[count].buffer, events[count].length, attrs);
 	    count++;
 	}

From 3d22acce6d22c9ad804dd91a8f6db45f90d072b1 Mon Sep 17 00:00:00 2001
From: Greg Eisenhauer <eisen@cc.gatech.edu>
Date: Mon, 15 Apr 2024 16:39:35 -0400
Subject: [PATCH 4/5] Fixes for FreeBSD, including upstream

---
 source/adios2/toolkit/transport/file/FileHTTP.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/source/adios2/toolkit/transport/file/FileHTTP.cpp b/source/adios2/toolkit/transport/file/FileHTTP.cpp
index 7407cb6ff7..ae18324075 100644
--- a/source/adios2/toolkit/transport/file/FileHTTP.cpp
+++ b/source/adios2/toolkit/transport/file/FileHTTP.cpp
@@ -8,6 +8,7 @@
  *      Author: Dmitry Ganyushin  ganyushin@gmail.com
  */
 #include "FileHTTP.h"
+#include <sys/socket.h>
 #include <arpa/inet.h>
 #include <cstring>
 #include <netdb.h>

From 6cbe3962c5e91cd6363949f2581c96223fbe879c Mon Sep 17 00:00:00 2001
From: Greg Eisenhauer <eisen@cc.gatech.edu>
Date: Mon, 15 Apr 2024 16:50:55 -0400
Subject: [PATCH 5/5] Prevent format from changing include order

---
 source/adios2/toolkit/transport/file/FileHTTP.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/source/adios2/toolkit/transport/file/FileHTTP.cpp b/source/adios2/toolkit/transport/file/FileHTTP.cpp
index ae18324075..6e52cde493 100644
--- a/source/adios2/toolkit/transport/file/FileHTTP.cpp
+++ b/source/adios2/toolkit/transport/file/FileHTTP.cpp
@@ -9,6 +9,7 @@
  */
 #include "FileHTTP.h"
 #include <sys/socket.h>
+
 #include <arpa/inet.h>
 #include <cstring>
 #include <netdb.h>
