diff --git a/connector/oidc/oidc.go b/connector/oidc/oidc.go
index 14329c00..2d7699e2 100644
--- a/connector/oidc/oidc.go
+++ b/connector/oidc/oidc.go
@@ -12,6 +12,7 @@ import (
 	"time"

 	"github.com/coreos/go-oidc/v3/oidc"
+	"golang.org/x/exp/slices"
 	"golang.org/x/oauth2"

 	"github.com/dexidp/dex/connector"
@@ -51,6 +52,7 @@ type Config struct {

 	// InsecureEnableGroups enables groups claims. This is disabled by default until https://github.com/dexidp/dex/issues/1065 is resolved
 	InsecureEnableGroups bool `json:"insecureEnableGroups"`
+	AllowedGroups []string `json:"allowedGroups"` // allowedGroups

 	// AcrValues (Authentication Context Class Reference Values) that specifies the Authentication Context Class Values
 	// within the Authentication Request that the Authorization Server is being requested to use for
@@ -180,6 +182,7 @@ func (c *Config) Open(id string, logger log.Logger) (conn connector.Connector, e
 		httpClient:                httpClient,
 		insecureSkipEmailVerified: c.InsecureSkipEmailVerified,
 		insecureEnableGroups:      c.InsecureEnableGroups,
+		allowedGroups:             c.AllowedGroups,
 		acrValues:                 c.AcrValues,
 		getUserInfo:               c.GetUserInfo,
 		promptType:                c.PromptType,
@@ -207,6 +210,7 @@ type oidcConnector struct {
 	httpClient                *http.Client
 	insecureSkipEmailVerified bool
 	insecureEnableGroups      bool
+	allowedGroups             []string
 	acrValues                 []string
 	getUserInfo               bool
 	promptType                string
@@ -331,6 +335,7 @@ func (c *oidcConnector) createIdentity(ctx context.Context, identity connector.I
 		return identity, errors.New("oidc: no id_token in token response")
 	}

+    c.logger.Debugf("Claims::: %q \n", claims)
 	// We immediately want to run getUserInfo if configured before we validate the claims
 	if c.getUserInfo {
 		userInfo, err := c.provider.UserInfo(ctx, oauth2.StaticTokenSource(token))
@@ -340,6 +345,7 @@ func (c *oidcConnector) createIdentity(ctx context.Context, identity connector.I
 		if err := userInfo.Claims(&claims); err != nil {
 			return identity, fmt.Errorf("oidc: failed to decode userinfo claims: %v", err)
 		}
+        c.logger.Debugf("UserInfo::: %q \n", userInfo)
 	}

 	const subjectClaimKey = "sub"
@@ -414,6 +420,28 @@ func (c *oidcConnector) createIdentity(ctx context.Context, identity connector.I
 				}
 			}
 		}
+        c.logger.Debugf("Groups::: %q \n", groups)
+
+        // Validate that the user is part of allowedGroups
+        var accessAllowed = false
+	    if len(c.allowedGroups) > 0 {
+            for _,group := range c.allowedGroups {
+                groupPresent := slices.Contains(groups, group)
+                if groupPresent {
+                    accessAllowed = true
+                    c.logger.Debugf("Found a match - Group::: %q \n", group)
+                    break
+                }
+            }
+        } else {
+            // don't check for groups if allowedGroups is not configured
+            c.logger.Debugf("Group check not performed \n")
+            accessAllowed = true
+        }
+
+        if !accessAllowed {
+	        return identity, errors.New("User is not in the allowed group(s)")
+        }
 	}

 	cd := connectorData{
diff --git a/server/handlers.go b/server/handlers.go
index 9438d807..7e970bed 100644
--- a/server/handlers.go
+++ b/server/handlers.go
@@ -467,7 +467,7 @@ func (s *Server) handleConnectorCallback(w http.ResponseWriter, r *http.Request)

 	if err != nil {
 		s.logger.Errorf("Failed to authenticate: %v", err)
-		s.renderError(r, w, http.StatusInternalServerError, fmt.Sprintf("Failed to authenticate: %v", err))
+		s.renderError(r, w, http.StatusUnauthorized, fmt.Sprintf("Failed to authenticate: %v", err))
 		return
 	}
